---
source: http://wiki.c2.com/?BigBallOfMud
original_source: http://www.laputan.org/mud/mud.html
original_author: "Brian Foote, Joseph Yoder"
original_date: "1999"
title: BigBallOfMud
contributors: [BrianFoote, MichaelFeathers, JeffGrigg, LlewelynThomas]
accessed: 2026-02-08
category: foundations
keywords: [big ball of mud, architecture, entropy, piecemeal growth, refactoring, shearing layers, throwaway code]
summary: "구조 없는 시스템은 예외가 아니라 소프트웨어의 기본 진화 상태다 — Foote & Yoder의 패턴 언어"
---

# Big Ball of Mud (거대한 진흙 덩어리)

Brian Foote와 Joseph Yoder는 1997년 PLoP 학회에서 소프트웨어 아키텍처의 불편한 현실을 꺼내놨다. 고수준 아키텍처 패턴이 주목받는 동안, 실제로 가장 널리 쓰이는 아키텍처는 아무도 이야기하지 않았다. 구조 없이 즉흥적으로 자란 **BIG BALL OF MUD**가 바로 그것이다. 이 논문은 7개의 패턴으로, 왜 그렇게 많은 시스템이 평범한 아키텍처에 머무는지 살핀다. wiki.c2.com에서는 [BrianFoote](http://wiki.c2.com/?BrianFoote), [MichaelFeathers](http://wiki.c2.com/?MichaelFeathers), [JeffGrigg](http://wiki.c2.com/?JeffGrigg) 등이 기회주의적 개발과 refactoring의 가치를 두고 토론했다.

> 원본 논문에는 건축과 도시의 은유적 사진이 포함되어 있다. 원문 참조: http://www.laputan.org/mud/mud.html

---

## Foote & Yoder의 원본 논문 (1999)

> **Big Ball of Mud**
> by Brian Foote and Joseph Yoder
> Department of Computer Science, University of Illinois at Urbana-Champaign

> *Fourth Conference on Patterns Languages of Programs (PLoP '97/EuroPLoP '97), Monticello, Illinois, September 1997. Pattern Languages of Program Design 4, Addison-Wesley, 2000.*

### Abstract

고수준 소프트웨어 아키텍처 패턴은 많은 관심을 받아 왔다. 하지만 업계에서 사실상 표준처럼 쓰이는 아키텍처는 아무도 이야기하지 않았다. 이 논문은 가장 흔하게 배포되는 소프트웨어 아키텍처인 **BIG BALL OF MUD**를 살핀다.

BIG BALL OF MUD는 즉흥적으로 만든 시스템이다. 계획 같은 건 없다. 구조가 있더라도 설계가 아니라 편의가 만든 구조다. 그런데 이 아키텍처가 계속 인기 있는 걸 단순히 무관심 탓으로 돌리기는 어렵다.

이 패턴들은 BIG BALL OF MUD를 만드는 힘(forces)을 파헤친다. 이 접근법이 왜 먹히는지도 살핀다. 이런 시스템을 만드는 사람들이 잘하고 있는 건 뭔가? 더 나은 아키텍처가 경쟁하려면, 진흙으로 가는 힘을 이해해야 한다. 대안도 살펴봐야 한다.

BIG BALL OF MUD 안에는 추가 패턴이 나타난다. 밑바닥에 두 가지 질문이 깔려 있다. 왜 그렇게 많은 시스템이 아키텍처적으로 평범한가? 어떻게 나아질 수 있는가?

### Introduction

지난 수년간 여러 저자가 고수준 소프트웨어 아키텍처 패턴을 내놓았다. PIPELINE이나 LAYERED ARCHITECTURE 같은 것들이다. 이상적인 세상이라면 모든 시스템이 이런 패턴의 모범이 됐을 것이다. 현실은 다르다. 실무에서 지배적인 아키텍처는 아직 아무도 이야기한 적 없다. **BIG BALL OF MUD**다.

BIG BALL OF MUD는 계획도 없고 구조도 엉망인 시스템이다. 덕트테이프와 철사로 겨우 버틴다. 스파게티 코드의 정글이다. 누구나 이런 시스템을 본 적 있다. 닥치는 대로 키우고, 그때그때 땜질한 흔적이 역력하다. 정보가 시스템 곳곳에 아무렇게나 공유된다. 거의 모든 중요 정보가 전역이거나 중복이다.

전체 구조가 처음부터 제대로 잡히지 않았을 수 있다. 잡혔더라도 알아볼 수 없을 만큼 닳았을 수 있다. 아키텍처 감각이 있는 프로그래머는 이 수렁을 피한다. 아키텍처에 관심 없고, 무너지는 제방의 구멍을 메우는 일상이 편한 사람만 이런 시스템에서 기꺼이 일한다.

그런데도 이 접근법은 살아남고 번성한다. 왜 인기가 있을까? 보기만큼 나쁜 걸까? 아니면 더 나은 결과물로 가는 중간 정거장일까? 좋은 프로그래머를 추한 시스템으로 몰아가는 힘은 뭘까? 피할 수 있을까? 피해야 할까? 어떻게 나아질 수 있을까?

7개의 패턴을 제시한다.

- **BIG BALL OF MUD**
- **THROWAWAY CODE**
- **PIECEMEAL GROWTH**
- **KEEP IT WORKING**
- **SHEARING LAYERS**
- **SWEEPING IT UNDER THE RUG**
- **RECONSTRUCTION**

왜 시스템이 BIG BALL OF MUD가 될까? 크고 추한 시스템은 종종 **THROWAWAY CODE**에서 시작한다. 한 번 쓰고 버리려고 급조한 코드다. 대충 만들고 문서도 없다. 그런데 저절로 생명을 얻는다. 작동하는데 왜 고치나? 비슷한 문제가 생기면, 처음부터 설계하기보다 이 코드를 고치는 게 더 빠르다. 시간이 지나면 일회용 프로그램이 BIG BALL OF MUD를 낳는다.

잘 잡힌 아키텍처를 가진 시스템도 구조적 침식에서 자유롭지 않다. 성공한 시스템에 밀려드는 요구사항 변경이 구조를 허문다. 한때 깔끔하던 시스템이 **PIECEMEAL GROWTH** 때문에 무성하게 자란다.

이런 확산을 막지 않으면 구조가 심하게 망가진다. 쇠퇴하는 동네처럼 하향 나선이 시작된다. 시스템을 이해하기 어려워진다. 유지보수 비용은 늘어난다. 좋은 프로그래머는 떠난다. 투자자는 자본을 뺀다. 하지만 동네처럼, 이 쇠퇴를 피하고 되돌릴 방법이 있다. 엔트로피에 맞서려면 에너지가 필요하다. 소프트웨어에서 엔트로피를 막는 방법은 refactoring이다. refactoring에 꾸준히 투자하면, 시스템이 BIG BALL OF MUD로 가라앉는 걸 막을 수 있다.

대홍수나 화재, 전쟁이 도시를 비울 수 있다. 하지만 보통은 건물이나 블록 단위로 변화가 진행된다. 도시 전체는 계속 기능한다. **KEEP IT WORKING** 전략은 성장하면서도 도시의 활력을 보존한다.

시스템의 구성 요소는 저마다 다른 속도로 진화한다. 빨리 변하는 것과 느리게 변하는 것이 갈린다. 그 사이에 **SHEARING LAYERS**가 생긴다. 단층선처럼, 지속적 추상화가 나타나도록 돕는다.

쇠퇴를 다스리는 간단한 방법이 있다. 황폐한 곳을 차단하고 그럴듯한 외관을 씌우는 것이다. 이게 **SWEEPING IT UNDER THE RUG**다. 더 심하면 전부 허물고 처음부터 시작해야 할 수도 있다. 전면 **RECONSTRUCTION**이 필요하면, 건질 수 있는 건 경험 밑에 깔린 패턴뿐이다.

이 패턴 중 일부는 안티패턴이나 허수아비처럼 보일 수 있다. 하지만 보통 말하는 안티패턴은 아니다. 우리가 말하는 것과 실제로 하는 것 사이의 격차를 살피는 것이다.

이중인격적 느낌을 줄 수 있으니, 솔직히 밝히겠다. 우리는 좋은 아키텍처를 지지한다.

궁극적으로 이 늪의 물을 빼려는 것이다. 가능하면 아키텍처 쇠퇴를 예방하고, 억제하고, 되돌려야 한다. 심각한 경우에는 아키텍처적 괴물을 철거해야 할 수도 있다.

동시에 이 수렁에서 허우적대는 사람들을 탓하려는 건 아니다. "죄를 미워하되 죄인은 사랑하라"가 부분적 태도다. 하지만 그 이상이다. 모든 뒤뜰 창고에 대리석 기둥이 필요하진 않다. 초기에는 기능이 아키텍처보다 먼저다. 아키텍처 통찰은 생명주기 초기보다 후기에 나타나는 경우가 많다.

만드는 과정에서 어느 정도의 통제된 혼돈은 자연스럽다. 뒷정리만 한다면 괜찮다. 복잡한 시스템은 문제를 아직 충분히 이해하지 못한 상태를 반영한다. 우아하게 만들 수 있는 범위보다 그냥 만들 수 있는 범위가 더 넓다. 잘 모르는 도메인에서는 허름한 아키텍처가 최첨단일 수 있다. 하지만 거기서 멈추면 안 된다. 경험이 쌓이면 더 오래가는 아키텍처 추상화를 뽑아내는 데 힘을 쏟아야 한다.

여기서 다루는 패턴들은 홀로 서지 않는다. 여러 패턴이 엮인 맥락 속에 있다. 특히 [Foote & Opdyke 1995]와 [Coplien 1995]의 생명주기 패턴, [Foote & Yoder 1996]의 SOFTWARE TECTONICS 패턴, [Roberts & Johnson 1998]의 framework 개발 패턴과 짝을 이룬다.

사실 이 논문 상당 부분은 병을 설명한다. 위 패턴들은 약을 설명한다. 설계와 refactoring이 산물의 생명주기 전체에 스며드는, 유연하고 피드백 중심의 개발 프로세스다.

### Forces

아키텍처에 신경 쓰는 조직조차 BIG BALL OF MUD를 만든다. 여러 힘이 그쪽으로 몬다. 이 "전역적" 힘은 모든 패턴에 작용한다.

**Time**: 설계 결정의 장기적 영향을 생각할 시간이 없다. 잘 설계된 시스템에서도 마감이 다가오면 아키텍처는 더 급한 것에 자리를 내준다.

소프트웨어 아키텍처가 자주 평범한 이유가 있다. 비용, 출시 시점, 역량 같은 것에 밀리기 때문이다. 사치품이나 완벽주의자의 취미로 여겨진다. 안타깝지만 이해는 된다. 아키텍처는 긴 호흡의 관심사다. 시장 출시 같은 단기 과제를 먼저 해결하지 않으면 제품이 죽는다. 좋은 아키텍처의 보상은 생명주기 후반에야 나온다. framework가 익고 재사용 가능한 컴포넌트가 나타나는 시점이다.

아키텍처를 **위험(Risk)**으로 볼 수도 있고, **기회(Opportunity)**로 볼 수도 있다. 위험으로 보면 시장 기회에 쓸 자원을 잡아먹는다. 기회로 보면 장기적 우위의 토대를 놓는다.

덜 익은 아키텍처가 성장하는 시스템에서 오히려 이점이 될 수 있다. 데이터와 기능이 인위적 제약 없이 자연스러운 자리로 옮겨갈 수 있기 때문이다. 너무 이른 아키텍처는 아키텍처가 없는 것보다 더 위험할 수 있다. 검증 안 된 가설이 진화와 실험을 가로막는 구속복이 된다.

**Cost**: 아키텍처는 비싸다. 특히 새 도메인을 탐색할 때 그렇다. 시스템이 겨우 출하할 만큼 돌아가면, 제대로 만드는 건 사치로 보인다. 투자 수익이 바로 나오지 않는다. 시장 진입을 너무 오래 미루면 장기적 관심사 자체가 의미 없어진다. **좋은 아키텍처가 비싸다고 생각한다면, 나쁜 아키텍처를 한번 겪어 보라.**

**Experience**: 시간과 의지가 있어도 도메인 경험이 부족하면 아키텍처를 정교하게 만들기 어렵다. 특히 초기에 그렇다. 초기 시스템은 프로그래머가 문제 해결에 필요한 조각을 파악하는 수단인 경우가 많다. 조각을 파악한 뒤에야 아키텍처 경계가 드러나기 시작한다.

직원 이동은 조직의 축적된 기억을 흩뜨린다. 새 피 수혈이라는 위안은 좀 의심스럽다.

**Skill**: 프로그래머마다 역량, 전문지식, 기질이 다르다. 좋은 추상화를 찾는 데 열정적인 사람이 있고, 복잡한 코드 수렁을 헤쳐나가는 데 능한 사람이 있다.

**Visibility**: 건물은 눈에 보인다. 짓는 과정도 보인다. 안에 들어가 설계를 감상할 수도 있다. 프로그램의 사용자 인터페이스는 건물 외관처럼 프로그램의 공적인 얼굴이다. 하지만 프로그램 내부는 만든 사람만 본다. 아키텍처가 방치되는 이유 중 하나다. 대부분이 "보닛 아래"에 있어서 아무도 못 본다. 돌아가고 출하할 수 있으면, 속이 어떻든 누가 신경 쓰겠는가?

**Complexity**: 뒤엉킨 아키텍처에는 이유가 있다. 소프트웨어가 도메인 자체의 복잡성을 그대로 반영하는 것이다. Brooks가 "본질적 복잡성(essential complexity)"이라 부른 것이다. 문제가 추하니까 소프트웨어도 추하다. 시스템의 조직은 그걸 만든 조직의 역사와 확장을 반영한다. Conway's Law다. 그 과정에서 생긴 타협도 반영한다.

**Change**: 아키텍처는 미래에 대한 가설이다. 앞으로의 변경이 설계 공간 안에 머물 거라고 주장한다. 세상은 예측을 비웃는다. "올바른" 행동은 재설계일 수 있다. 더 흔한 결과는 구조 따위 신경 안 쓰고 새 요구사항을 대충 끼워넣는 것이다.

**Scale**: 대규모 프로젝트 관리는 소규모와 질적으로 다르다. 보병 사단을 이끄는 것과 특수부대를 지휘하는 건 다르다. Alan Kay는 OOPSLA '86에서 말했다. "좋은 아이디어가 항상 확장되는 건 아니다." Henry Lieberman이 물었다. "그러면 나쁜 것만 확장하나요?"

### BIG BALL OF MUD

> *별칭: SHANTYTOWN, SPAGHETTI CODE*

판자촌은 누추하고 엉망인 빈민가다. 나쁜 생각이라는 걸 모두가 안다. 그런데도 여러 힘이 합쳐져서 판자촌이 생겨난다. 이들이 잘하고 있는 건 뭘까?

판자촌은 흔하고 싼 재료와 단순한 도구로 짓는다. 숙련공이 필요 없다. 전문 분업도 거의 없다. 거주자가 직접 짓고 직접 고친다. 뭐든 할 줄 알아야 한다. 인프라에는 관심이 적다. 조율, 자본, 전문 자원이 필요하기 때문이다. 전체 계획이나 성장 규제도 거의 없다. 판자촌은 집이 필요하고, 비숙련 노동력은 넘치고, 투자할 돈은 없는 곳에 나타난다. 더 멋진 아키텍처는 나중의 사치다.

우리 소프트웨어 중 너무 많은 것이 판자촌 수준이다. 도구와 인프라 투자가 부족하다. 각 부분이 아무 검증 없이 자란다. 인프라와 아키텍처가 없으니 한 부분의 문제가 옆으로 번진다. 마감은 몬순처럼 다가온다. 아키텍처의 우아함은 꿈도 못 꿀 지경이다.

시스템이 완성에 가까워지면 실제 사용자가 처음으로 써보기 시작한다. 이 경험이 확정됐던 아키텍처 결정을 뒤흔든다. Brooks가 지적했듯, 소프트웨어가 유연하기 때문에 개발 후반에 아키텍처 타협을 떠안는다. 바로 그 유연성 때문이다.

완벽을 추구할 시간과 돈은 거의 없다. 그래야 할 이유도 없다. 소프트웨어를 돌아가게 만들고 제때 내보내는 게 먼저다. 팀이 여유 있게 끝내면, 관리자는 다음에 시간과 인원을 줄여야 한다는 신호로 받아들인다.

**제 시간에, 예산 내에서, 품질 있는 소프트웨어를 전달해야 한다.**

Ralph Johnson은 즐겨 이렇게 말한다. "평균적 조직에는 평균적 인재가 있다." BIG BALL OF MUD가 인기 있는 이유 하나가 여기 있다. 모든 자리에 초생산적 거장 아키텍트를 앉힐 필요가 없다.

**먼저 기능에 집중하라. 그 다음이 아키텍처와 성능이다.**

이 주장은 Gabriel의 "[WorseIsBetter](http://wiki.c2.com/?WorseIsBetter)" 논증과 여러 면에서 닮았다. 왜 최선을 다해도 그렇게 많은 소프트웨어가 BIG BALL OF MUD가 될까? 왜 화전 전술이 우아함을 몰아낼까?

참호 속 프로그래머 눈에 이 진흙투성이 코드는 어떻게 보일까? 데이터 구조가 대충이거나 아예 없을 수 있다. 모든 것이 모든 것과 대화한다. 중요한 상태 데이터가 전역이다. 변수와 함수 이름이 아무 의미 없거나 오해를 부른다. 함수는 길고 복잡하다. 관련 없는 일을 한다. 코드가 중복된다. 제어 흐름을 따라가기 힘들다. 프로그래머의 의도를 알아내기가 거의 불가능하다. 읽을 수 없다. 해독 불가에 가깝다. 문서? 무슨 문서?

BIG BALL OF MUD를 안티패턴으로 볼 수도 있다. 아키텍처를 갉아먹는 힘에 끌려다니면 수렁에 빠진다. 하지만 부인할 수 없는 인기가 결론을 내린다. 이것 자체가 패턴이다. 작동하는 시스템을 만드는, 널리 퍼진 반복적 해결책이다.

경직된 하향식 설계도 답이 아니다. 일부 분석가와 아키텍트는 구현 전에 모든 걸 잡을 수 있다고 믿는다. 이 접근법은 자원 낭비와 분석 마비(analysis paralysis), 설계 막다른 골목으로 이끈다.

Kent Beck은 이렇게 말했다.

**Make it work. Make it right. Make it fast.**

"만들어라"는 기능에 집중하라는 뜻이다. 일단 돌아가게 하라. "올바르게 만들어라"는 조각을 파악한 뒤 구조를 잡으라는 뜻이다. "빠르게 만들어라"는 우아한 아키텍처를 확보한 뒤 성능을 최적화하라는 뜻이다.

소프트웨어 아키텍처에서 **형태는 기능을 따른다(form follows function)**. 시스템 요소의 독립적 정체성은 코드가 돌아간 뒤에야 드러나기 시작하는 경우가 많다.

도메인 경험은 모든 framework 설계에서 필수다. 도메인의 아키텍처 요구를 모르면서 하향식 설계를 시도하는 건 성급하거나 무모한 일이다.

아키텍처가 너무 오래 과소평가됐다. 많은 엔지니어가 BIG BALL OF MUD와 사는 걸 당연하게 여긴다. 일부 엔지니어는 이 수렁을 헤쳐나가고 길을 안내하는 데 뛰어나다. 시간이 지나면 아키텍처와 역량 사이의 공생이 조직 성격을 바꾼다. 늪 안내인이 아키텍트보다 더 가치 있어진다. Conway's Law에 따라 아키텍트는 무력감 속에 떠난다. 진흙투성이 세부를 꿰뚫은 엔지니어가 남는다.

[Foote & Yoder 1998a]는 더 나아간다. 읽기 어려운 코드가 변경하기 어렵다는 덕분에 **생존 이점**을 가질 수 있다고 봤다.

숙련 프로그래머는 동료보다 빠르게 복잡성을 만든다. 문서화하고 설명하는 것보다 더 빠르게. 보급선을 추월하는 군대처럼, 복잡성은 안정적으로 감당할 수 없는 지점까지 불어난다. wiki-wiki web의 저자들이 **프로그래밍의 피터 원리(Peter Principle)**라 부른 현상과 비슷하다. 복잡성은 편하게 감당할 수 있는 수준 바로 너머까지 빠르게 불어난다. 이 지점에서 복잡성과 통제력이 불안한 균형에 이른다. 전격전이 포위전으로 교착된다.

프로그래머의 서열은 단순하고 명쾌한 코드의 장인다운 전시보다, 영리함의 과시로 정해지는 경우가 많다. 문화가 칭찬하는 것이 번성한다.

BIG BALL OF MUD를 다루는 방법은 세 가지다. 첫째, 시스템을 건강하게 유지한다. 확장과 통합을 꾸준히 번갈아 하면 구조를 유지하고 개선할 수 있다. 둘째, 버리고 처음부터 다시 시작한다. RECONSTRUCTION이 이 대안을 다룬다. 셋째, 엔트로피에 항복하고 수렁에 빠진다.

로마 건축가 Marcus Vitruvius 이래 건축가는 세 가지에 집중했다. **견고함(Firmitas)**, **유용성(Utilitas)**, **아름다움(Venustas)**. BIG BALL OF MUD는 보통 미학 위에 유용성이 이긴 결과다. 장인정신이 기능을 위해 희생된다. 구조와 내구성도 희생될 수 있다. 이해할 수 없는 프로그램은 고치려는 시도 자체를 거부하기 때문이다.

### THROWAWAY CODE

> *별칭: QUICK HACK, KLEENEX CODE, DISPOSABLE CODE, SCRIPTING, KILLER DEMO, PERMANENT PROTOTYPE, BOOMTOWN*

집주인이 임시 창고나 간이 차고를 세운다. 곧 허물고 더 제대로 된 것으로 바꾸겠다는 생각이다. 이런 구조물은 끝없이 살아남는 경향이 있다. 바꿀 돈이 안 모일 수 있다. 새 것을 지어도, 예전 것을 "잠깐만 더" 쓰고 싶은 유혹을 뿌리치기 어렵다.

시스템 프로토타입을 만들 때도 마찬가지다. 코드가 우아한지, 효율적인지 신경 안 쓴다. 개념 증명용이다. 프로토타입이 끝나면 버리고 제대로 만들 거다.

시연이 다가오면, 최종 기능을 인상적이지만 비효율적으로 구현해서 프로토타입에 싣는 유혹이 생긴다. 이 전략이 때로 너무 잘 먹힌다. 고객이 다음 단계 자금을 대는 대신, 프로토타입 자체를 출시 일정에 올려버릴 수 있다.

**작은 문제에 대한 즉각적 해결책이나, 빠른 프로토타입이 필요하다.**

시간 부족이 프로그래머를 THROWAWAY CODE로 모는 가장 큰 힘이다. 제대로 설계된 프로그램을 만들려면 문제의 가치에 비해 시간이 너무 오래 걸릴 수 있다. 프로그래머는 최소 기능 프로그램을 미친 듯이 만들면서, 더 우아한 버전이 뒤따를 거라 약속한다.

급조 코딩은 임시방편으로 합리화된다. 후속 작업을 할 시간은 결코 오지 않는다. 코드는 방치되지만 프로그램은 번성한다.

**가용한 어떤 수단이든 사용하여, 당면한 문제만을 해결하는 단순하고 일회용인 코드를 만들어라.**

THROWAWAY CODE는 다른 사람의 복잡한 코드를 재사용하는 대신 새로 만들기도 한다. 마감이 다가오면 계산이 바뀐다. 내가 돌아가는 프로그램을 만들 수 있다는 확신이 남의 라이브러리를 배우는 비용보다 커진다.

프로토타입을 만들면 항상 위험이 따른다. 누군가 "됐다, 그냥 출하해"라고 할 위험이다. 이 위험을 줄이는 방법이 있다. 프로덕션에 쓸 수 없는 언어로 프로토타입을 만드는 것이다. [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)에서는 이걸 "spike solution"이라 한다. 문제 공간을 배우는 데 도움이 되지만, 좋은 설계로 착각하면 안 된다.

모든 프로그램이 정교한 설계를 갖출 필요는 없다. 단순한 일회용 프로그램은 광업 붐타운과 같다. 5년 후 유령 도시가 될 걸 알면 50년짜리 해결책이 필요 없다.

**THROWAWAY CODE의 진정한 문제는 버려지지 않을 때 발생한다.**

THROWAWAY CODE를 만드는 건 거의 보편적 관행이다. 예를 들어 PLoP 온라인 등록 코드와 Wiki-Wiki Web 페이지가 있다.

PLoP 등록 코드는 4대 기계에서 두 대륙에 걸쳐 돌아가는 분산 웹 애플리케이션이었다. HTML, 빌려 온 C 데모 코드, csh 스크립트를 급하게 모아 시작했다. 웹 기반 양식 처리의 실험이었다. 저자의 기대를 훌쩍 넘어 성공했다. 지금도 본질적으로 같은 구성이다.

Wiki-Web 코드도 Ward Cunningham이 시작한 CGI 실험에서 출발했다. "wiki"라는 이름은 하와이 휴가에서 따왔다. 공항 셔틀에서 본 하와이어 "빠른(quick)"이 어원이다. Wiki Web은 방문자가 다른 사람이 쓴 걸 마음대로 바꿀 수 있다. 기물파손의 처방전처럼 보인다. 하지만 실제로 잘 돌아갔다.

일회용 코드의 아키텍처 침식은 별도 객체, 패키지, 모듈에 격리해서 줄일 수 있다. 격리할 수 있으면 건강한 부분에 미치는 영향이 줄어든다.

일회용이라던 코드가 살아남을 게 뻔해지면, 두 가지 길이 있다. **PIECEMEAL GROWTH**의 점진적 과정이나, **RECONSTRUCTION**의 새 초안이다.

### PIECEMEAL GROWTH

> *별칭: URBAN SPRAWL, ITERATIVE-INCREMENTAL DEVELOPMENT*

도시 계획의 성적표는 고르지 않다. Washington D.C.는 L'Enfant의 마스터플랜으로 배치됐다. Brasilia와 Abuja도 도면 위에서 시작했다. Houston 같은 도시는 전체 계획 없이 자랐다.

대부분의 도시는 Abuja보다 Houston에 가깝다. 작은 정착지로 시작해 시간이 지나면서 임계 규모에 이른다. 양의 피드백 순환이 시작된다. 성공이 상인, 의사, 성직자를 끌어들인다. 설립자들은 대도시를 세우고 있다고 생각한 적 없었다. 야망은 소박했고 당장의 것이었다.

waterfall 프로세스를 비판하는 게 유행이 됐다. 죽은 말이지만 질긴 말이다. 접근법 자체는 신임을 잃었지만, 경직된 하향식 프로세스의 유산은 다양한 모습으로 살아남는다.

waterfall 이전의 선구자들은 비공식적인 "코드 앤 픽스(code-and-fix)" 접근법을 썼다. 결과는 너무 자주 BIG BALL OF MUD였다. waterfall은 이 진흙에 대한 반응이었다. 코드 앤 픽스가 소규모에는 괜찮았을지 모르지만, 규모가 커지면 안 됐다.

오늘날 설계자는 변하는 요구사항의 공세를 맞닥뜨린다. 기술의 급성장과 급변하는 비즈니스 환경 때문이다. 마스터플랜은 종종 경직되고, 시대에 뒤처진다.

**Change**: 하향식 설계의 근본적 문제가 있다. 요구사항이 움직이는 과녁이라는 것이다. 한 번에 영원히 해결할 수 없다. 끝날 무렵에는 문제가 변해 있다. 고객이 원하는 걸 그냥 해줄 수 없다. 고객 자신도 뭘 원하는지 모르는 경우가 많다. 그냥 계획하는 게 아니라, 적응할 수 있도록 계획해야 한다.

**Aesthetics**: 사전 설계의 목표는 코드를 쓰기 전에 시스템의 중요한 요소를 잡는 것이다. 최고의 설계란 코드 한 줄 전에 구조를 우아하고 빈틈없이 명세하는 것이라 본다. 하지만 흔들리는 요구사항 앞에서 이런 바람은 허망하다. 매 홀에서 홀인원을 바라는 것과 같다. 예상한 문제가 안 생길 수 있다. 노력은 낭비된다. 해결책이 오히려 쓸데없는 복잡성을 끌어들인다.

가장 독한 형태에서, 변화를 미리 잡으려는 욕구는 분석 마비로 이끈다. 상상 속 우발 상황의 그물이 설계 공간을 꼼짝 못 하게 묶는다.

**변화와 성장을 촉진하는 힘에 점진적으로 대응하라. 성장 기회가 발생할 때 활용하라. 끊임없이 refactoring하라.**

성공한 소프트웨어는 더 넓은 사용자를 끌어들인다. 새 요구사항은 원래 설계의 결을 거스를 수 있다. 우아하게 만드는 것과 빠르게 해결하는 것 사이에서 고를 때, 아키텍처는 보통 진다. [Foote 1988]은 이를 **midlife generality loss(중년기 일반성 상실)**라 불렀다.

*How Buildings Learn*에서 Brand는 이렇게 봤다. **High Road** 아키텍처는 비싸고 바꾸기 어려운 건물을 만드는 경우가 많다. 반면 방갈로나 창고 같은 **Low Road** 건물이 역설적으로 훨씬 더 적응적이다. Brand의 말이다. **기능이 형태를 녹인다(Function melts form)**. Low Road 건물이 변화에 더 잘 따라간다.

소프트웨어에서도 마찬가지다. 다른 프로그래머의 성당을 더럽히기는 꺼린다. 하지만 아키텍처적 허세가 없는 Low Road 시스템에 대한 편의적 수정은 합리화하기 쉽다.

Christopher Alexander는 이렇게 말했다.

> 유기적 성장과 수리의 프로세스는 점진적 변화의 순서를 만들어야 한다. 이 변화는 모든 규모 수준에 고르게 분배되어야 한다. 방, 건물 날개, 창, 길의 수리에도 새 건물 창조만큼 관심이 있어야 한다. 그래야 환경이 전체로서도, 부분으로서도, 역사의 모든 순간에 균형을 이룬다.

Alexander는 모기지와 자본 지출 정책의 문제를 지적했다. 초기에 큰 돈을 쓸 수 있게 하지만, 유지보수와 진화를 위한 자원은 안 준다. 소프트웨어 세계에서도 마찬가지다. 생명주기 초기에 숙련된 인력을 배치한다. 유지보수는 자원이 부족할 때 주니어에게 넘긴다. 마스터 플래닝이라는 허구의 대가를 치르는 건 이른바 유지보수 단계다.

PIECEMEAL GROWTH에서 가장 눈에 띄는 건 **피드백(Feedback)**의 역할이다. Herbert Simon은 이렇게 봤다. 진화로 만들어진 적응 시스템 중, 미래에 대처하는 주된 수단으로 예측에 기대는 것은 거의 없다. 항상성(homeostasis)과 회고적 피드백이 훨씬 더 효과적이다. 변화에 빠르게 적응할 수 있다면 예측은 덜 중요해진다. Brand의 말처럼 **예지(foresight)보다 후지(hindsight)가 낫다**. 이게 [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)의 핵심 원칙 중 하나의 기초다. **[YouArentGonnaNeedIt](http://wiki.c2.com/?YouArentGonnaNeedIt)** (어차피 필요 없을 거다).

XP 지지자들은 말한다. 자기가 생각하는 만큼 똑똑하지 않은 척하라. 똑똑한 아이디어가 정말 필요할 때까지 기다려서 구현하라. 맞았으면 오는 걸 봤으니 뭘 할지 안다. 틀렸으면 아무도 원하지 않는 "투기 주택"을 허물 필요가 없다.

[ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)은 피드백에 크게 기댄다. 짧은(3주) 반복과 사용자와의 지속적 대화로 요구사항과 코드를 맞춘다. 광범위한 사전 계획은 안 한다. 가능한 빨리 돌아가는 코드를 만들고, 피드백에 따라 프로토타입을 조종한다.

PIECEMEAL GROWTH의 가장 큰 위험은 전체 구조를 조금씩 갉아먹어 BIG BALL OF MUD로 만드는 것이다. **KEEP IT WORKING** 전략과 밀접하다. 두 패턴 모두 만성적이고 아키텍처적인 관심사를 뒤로 미루고 급하고 지역적인 관심사를 앞세운다.

이 힘에 맞서려면 통합과 refactoring에 끊임없이 헌신해야 한다. 지역적 힘과 전역적 힘이 시간이 지나면서 조화된다. Alexander의 말을 다시 빌린다.

> 유기적 성장과 수리의 프로세스는 점진적 변화의 순서를 만들어야 한다. 이 변화는 모든 규모 수준에 고르게 분배되어야 한다.

### KEEP IT WORKING

> *별칭: VITALITY, BABY STEPS, DAILY BUILD, FIRST, DO NO HARM*

> *우리를 계속 전진하게 하는 가장 큰 요인은 시스템을 항상 사용하고, 새로운 것을 계속 시도한다는 것이다. 이 "함께 살기"가 실패를 근절하고, 불일치를 정리하고, 때로 혁신에 영감을 준다.* — Daniel H. H. Ingalls

도시가 인프라를 구축하면 그걸 돌아가게 유지하는 게 필수다. 하수도가 고장나면 빨리 고쳐야 한다. 방치하면 불쾌함에서 생명 위협으로 악화된다.

소프트웨어도 마찬가지다. 기업은 소프트웨어 인프라에 결정적으로 의존한다. 24시간 쉬지 않고 돌아야 하는 미션 크리티컬 시스템이 있다. 다운되면 재고를 확인할 수 없다. 급여를 줄 수 없다. 항공기 경로를 잡을 수 없다.

대규모 점검을 위해 시스템을 내릴 때가 있다. 하지만 보통 위험하다. 다시 올라왔을 때, 대규모 수정 중 어느 것이 새 문제를 일으켰는지 알기 어렵다. 모든 변경이 용의자다. 통합을 미루는 건 재앙의 처방이다.

Capers Jones는 중대한 변경에 새 버그가 섞일 확률을 약 7%로 봤다. **Bad Fix Injection**이라 불렀다. 낮아 보인다. 하지만 복리로 쌓이면, 여러 업그레이드가 시스템을 깨뜨릴 확률은 빠르게 올라간다.

**유지보수 필요가 쌓였지만, 대규모 점검은 시스템을 깨뜨릴 수 있다.**

자기가 짓는 집에 사는 건축가는 일을 제대로 할 동기가 분명하다. 실수와 지름길은 자기 둥지를 더럽힐 뿐이다. 아키텍트-빌더 아이디어는 Alexander 작업의 중심 주제다.

**소프트웨어를 유지하고 작동시키기 위해 필요한 것을 하라. 계속 작동시켜라.**

자기가 짓는 시스템에서 살면, 아무것도 깨뜨리지 않으려는 강한 동기가 생긴다. 배관 장애는 직접적인 불편이다. 짧게 끝낼 이유가 있다. 때로 활선(live wire) 작업을 해야 한다. 각별히 조심해야 한다. 돌아가는 시스템과 함께 일하는 주된 이점은 피드백이 직접적이고 거의 즉각적이라는 것이다.

이 전략에는 강점이 있다. 시스템을 깨뜨리는 수정이 바로 거부된다. 진화의 어느 지점에서든 앞으로 갈 경로는 많다. 대부분은 막다른 길이다. 생존 능력을 해치지 않는 것만 고르면 막다른 길을 피할 수 있다.

설계 공간은 광활하고 어두운, 대부분 탐험되지 않은 숲이다. 신중한 전략은 길에서 너무 멀리 벗어나지 않는 것이다. 작은 걸음을 내딛으면 돌아가는 시스템까지 몇 걸음이면 돌아올 수 있다.

Brooks는 "[NoSilverBullet](no-silver-bullet.md)"에서 이렇게 인용했다.

> 몇 년 전, Harlan Mills는 모든 소프트웨어 시스템이 점진적 개발로 키워져야 한다고 제안했다. 시스템을 먼저 실행되게 만든다. 아직 유용한 것은 하지 않지만 적절한 더미 서브프로그램을 호출한다. 그런 다음 조금씩 살을 붙인다. (...) 프로세스의 모든 단계에서 항상 작동하는 시스템을 갖는다. 4개월 만에 만들 수 있는 것보다 훨씬 더 복잡한 것을 키울 수 있다.

Microsoft는 매 근무일 끝에 각 제품의 **DAILY BUILD**를 의무화한다. 이 접근법과 마지막으로 돌아가는 버전을 유지하는 것은 성공적 유지보수 프로그래머 사이에서 거의 보편적 관행이다.

시스템의 지속적 활력을 보장하는 또 다른 요소가 있다. 테스팅에 대한 헌신이다. 돌아가는지 확인할 방법 없이 돌아가는 상태를 유지하기는 어렵다. 테스팅은 [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)의 기둥 중 하나다. XP에서는 코드 한 줄 전에 단위 테스트를 먼저 만든다.

### SHEARING LAYERS

> *벌새와 꽃은 빠르고, 삼나무는 느리고, 삼나무 숲 전체는 더 느리다. 대부분의 상호작용은 같은 속도 수준 내에서 일어난다.* — R. V. O'Neill, *A Hierarchical Concept of Ecosystems*

SHEARING LAYERS 개념은 Brand의 *How Buildings Learn*의 핵심 요소다. Brand는 영국 디자이너 Frank Duffy와 생태학자 R. V. O'Neill 등 여러 곳에서 아이디어를 모았다.

Brand는 Duffy의 말을 빌린다. "우리의 기본 논증은 건물이라는 것은 없다는 것이다. 제대로 생각한 건물은 건축 구성 요소의 여러 수명 층이다."

Brand는 Duffy의 층을 6개로 다듬었다.

- **Site (부지)**: 지리적 위치. 영원하다.
- **Structure (구조)**: 기초와 골격 같은 하중 지지 요소. 30~300년 지속될 수 있다.
- **Skin (외피)**: 외장과 창 같은 외부 표면. 환경과 유행에 반응하며 약 20년이다.
- **Services (설비)**: 난방, 배선, 배관. 건물의 순환계와 신경계다. 기술적 진부화에 더 빨리 밀려 7~15년이다.
- **Space Plan (공간 계획)**: 벽, 바닥, 천장. 상업적 환경에서 3년마다 바뀔 수 있다.
- **Stuff (물건)**: 램프, 의자, 가전제품. 끊임없이 변동한다.

소프트웨어 시스템은 멈출 수 없다. 비트로 만들어졌기 때문에 변화의 부담을 자주 떠안는다.

**서로 다른 산물은 서로 다른 속도로 변한다.**

**Adaptability**: 다른 조건이 같다면, 다양한 요구사항을 쉽게 소화할 수 있는 시스템이 유리하다. 예상 못 한 요구사항을 거의 재설계 없이 처리한다.

**Stability**: 시스템은 맡은 일을 최대한 잘 해서 성공한다. 자리를 잡은 뒤에는 단기적 관심사가 핵심 요소를 씻어내지 않게 해야 한다.

적응성과 안정성은 끊임없이 긴장한다. 새로움에 흔들리면 안 된다. 즉흥적 모험에 유산을 낭비해서도 안 된다.

**유사한 속도로 변하는 산물이 함께 있도록 시스템을 분해하라.**

시스템 안에서 대부분의 상호작용은 같은 층 안에서 또는 이웃한 층 사이에서 일어난다. 각 층은 비슷한 속도로 변하는 것을 모으는 경향이 있다. 다른 속도로 변하는 것은 갈라진다. 변화 속도의 차이가 층의 출현을 부추긴다. Brand는 직업적 전문화도 이 층과 함께 나타난다고 했다.

소프트웨어에서 이런 층을 찾을 수 있을까?

맨 아래에는 **데이터**가 있다. 가장 빨리 변하는 것은 데이터로 간다. 변경에 가장 잘 따라오기 때문이다. 데이터는 사용자와 상호작용한다.

**코드**는 데이터보다 느리게 변한다. 프로그래머, 분석가, 설계자의 영역이다. 객체지향 언어에서 빨리 변할 것은 블랙박스 다형적 컴포넌트로 만든다. 덜 자주 변할 요소는 화이트박스 상속을 쓸 수 있다.

객체지향 **framework**를 이루는 추상 클래스와 컴포넌트는 애플리케이션보다 느리게 변한다. framework를 낳은 애플리케이션에서 공통적이고 오래가는 것을 뽑아내는 역할이다.

framework가 진화하면서 특정 추상화는 개별 애플리케이션에서 시스템 **인프라**로 옮겨간다. 모든 요소가 이 여정을 하지는 않는다. 하는 것들은 프로젝트의 가장 귀한 유산이다.

**언어**는 framework보다 느리게 변한다. 학자와 표준 위원회의 관할이다. 언어가 적절히 신중한 속도로 진화하게 하는 것이 이들의 전통적 역할이다.

빠르게 진화하는 산물은 역동성과 유연성을 준다. 느리게 진화하는 산물은 변화에 대한 보루다. 이전 환경과의 상호작용에서 쌓은 지혜를 담고 있다. 먹혔던 것을 지킨다.

시간이 지나면서 framework, 추상 클래스, 컴포넌트는 도메인 구조에 대한 배움을 담는다. 오래가는 통찰은 주요 구조 요소 쪽으로 이동한다. 변동 중인 것은 사용자가 상호작용하는 데이터로 밀려난다. 소프트웨어 진화는 **변화에 의해 돌려지는 원심분리기**와 같다. 시간이 지나면 하향식 의제가 고안한 것보다 훨씬 더 진실한 타협에 이를 수 있다.

Christopher Alexander는 이렇게 말했다.

> 좋은 것에는 특정한 종류의 구조가 있다. 그 구조는 동적으로만 얻을 수 있다. 자연에서는 지속적이고 매우 작은 피드백 루프 적응이 진행된다. 그래서 사물이 조화롭게 된다. 시간 차원이 없었다면 그렇게 되지 않았을 것이다. 그런데 우리가 세상을 만드는 주요 역할을 하면서, 이것을 깨닫지 못하고 있다. 매우 심각한 문제다.

### SWEEPING IT UNDER THE RUG

> *별칭: POTEMKIN VILLAGE, HOUSECLEANING, PRETTY FACE, QUARANTINE, HIDING IT UNDER THE BED, REHABILITATION*

문제를 덮어버린 가장 극적인 사례가 있다. 소련 엔지니어들이 체르노빌 4호 원자로에 만 년짜리 뚜껑을 덮으려고 만든 콘크리트 석관이다.

문제를 없앨 수 없다면 적어도 숨길 수 있다. 도시 재개발은 그래피티 위에 벽화를 그리고, 버려진 건물 주위에 울타리를 두르는 것으로 시작한다. 아이들은 바닥 한가운데 난장판보다 옷장 안 한 무더기가 낫다는 걸 배운다.

미적 관심이나 직업적 자부심 말고도 지저분한 코드를 정리할 이유가 있다. 마감이 다가온다. 동료가 당신의 코드를 호출하고 싶어 한다. 호출할 수 있는 인터페이스만 내놓으면 된다. 알아보기 쉬운 인터페이스를 안 내놓으면 다른 사람 코드를 쓸 것이다.

BIG BALL OF MUD를 처음 보면 공포와 절망이 밀려온다. 아키텍처 무결성으로 가는 첫걸음이 있다. 엉망인 부분을 찾아내고 격리하는 것이다. 문제 영역을 차단하면 분할 정복으로 정리할 수 있다.

**무성하게 자란 스파게티 코드는 이해하기 어렵고, 고치기 어렵고, 확장하기 어렵다. 내버려 두면 점점 더 나빠진다.**

**문제를 쉽게 없앨 수 없다면 적어도 차단하라. 무질서를 정해진 영역에 가두라. 눈에 띄지 않게 하라. 추가 refactoring을 위한 무대를 마련하라.**

한곳에 몰아넣었으면 적어도 어디 있는지 안다. 여전히 먼지 무더기지만, 흩어져 있지는 않다. 손님은 못 본다. 체르노빌 엔지니어들이 보여줬듯, 때로는 정리에 착수하기 전에 뚜껑을 먼저 덮어야 한다.

스파게티 코드를 다루려면 덜 엉킨 부분을 찾아야 한다. 거기서 아키텍처 경계를 그리기 시작하라. 전역 정보를 구분되는 데이터 구조로 나누라. 잘 정의된 인터페이스로 영역 간 통신을 강제하라. 이게 개념적 무결성을 다시 세우는 첫걸음이다.

낡은 영역에 새 인터페이스를 두르는 것은 아키텍처 재건의 첫걸음이다. 하지만 긴 여정이다. BIG BALL OF MUD에서 의미 있는 추상화를 뽑아내는 건 어렵고 까다롭다. 역량, 통찰, 인내가 필요하다. 때로 RECONSTRUCTION이 덜 고통스러워 보인다.

불가능하지는 않다. 달걀 풀기와는 다르다. 현실 세계의 재건처럼, 자원과 헌신이 필요하다.

종종 FACADE [Gamma et al. 1995]를 구축하여 불쾌함에 "예쁜 얼굴"을 씌운다.

### RECONSTRUCTION

> *별칭: TOTAL REWRITE, DEMOLITION, THROW AWAY THE FIRST ONE, START OVER*

Atlanta의 Fulton County Stadium은 1966년에 건설됐다. 야구의 Atlanta Braves와 미식축구의 Atlanta Falcons의 홈구장이었다. 1997년에 철거됐다.

빠른 진부화에는 두 가지가 작용했다. 원래 아키텍처가 '90년대 스포츠 경제가 요구하는 "스카이박스" 스위트를 수용할 수 없었다. 어떤 개조로도 안 됐다. 처음부터 다시 해야 했다. 야구와 미식축구 관중 모두를 위한 범용 해결책이 양쪽 다 타협시켰다. 겨우 31년 만에 두 개의 단일 목적 경기장으로 바뀌었다.

예상 못 한 요구사항과 범용 설계에 대한 교훈이 있다.

> *Plan to Throw One Away (You Will Anyway)* — Brooks

[ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)은 Chrysler Comprehensive Compensation 프로젝트(C3)에서 시작했다. 표류하는 프로젝트의 구원 요청과 1년 반치 작업의 폐기에서 출발했다. 새로 시작하면서 잡은 프로세스가 XP의 토대가 됐다.

하지만 초기의 실패한 초안에서 건진 경험의 가치에는 덜 주목한다. 이 첫 번째 초안이 이야기의 숨은 영웅이 아니었을까?

**코드가 수리는커녕 이해조차 불가능한 지점까지 쇠퇴했다.**

**Obsolescence**: 시스템을 포기하는 이유 중 하나가 있다. 정말로 쓸모없어진 것이다. 기술적 진부화와 경제적 진부화는 별개다. 최첨단이 아닌 시스템이 잘 팔릴 수 있다. 기술적으로 우월한 시스템이 비기술적 이유로 질 수 있다.

콘크리트와 강철의 세계에서 황폐는 증상이다. 자본 철수가 원인이다. 이 과정이 시작되면 저절로 강화된다. 반면, 꾸준히 자원을 넣으면 건물은 끝없이 지속된다. 엔트로피만이 아니라, 엔트로피에 맞서지 않으려는 의지가 쇠퇴를 부른다. 유럽에서는 동네가 수백 년간 번성해 왔다.

**Change**: 소프트웨어는 고도로 유연하다. 하지만 새 요구가 아키텍처 가정을 가로지르면 받아들이기가 거의 불가능해진다. 이런 경우에 전면 재작성이 유일한 답일 수 있다.

**Cost**: 시스템을 버리는 건 트라우마다. 소프트웨어는 회계상 자산으로 취급되며 비쌀 수 있다. 하지만 재작성이 개념적 설계나 직원의 경험까지 버리는 건 아니다.

**버리고 처음부터 다시 시작하라.**

이전 시스템을 만든 사람이 이미 떠났을 수 있다. 재작성은 새 인력이 아키텍처와 구현 사이의 감각을 다시 잡는 방법이다. 때로 시스템을 이해하는 유일한 방법은 직접 만드는 것이다. 새 초안은 활력을 불어넣는다. 수렁이 사라진다.

새 시스템을 만드는 동기가 있다. 경험이 충분하다는 느낌일 수 있다. 이전 버전의 실패에 참여한 것이 그 경험을 준다.

새 시스템은 진공 속에서 설계되지 않는다. Brooks의 타르 구덩이를 발굴하고 화석을 조사한다. 이전 시스템에 대한 철저한 사후 검토가 필수다.

BIG BALL OF MUD가 되면, 알아볼 수 없는 코드가 적응을 어렵게 한다. 종말을 앞당긴다. 변화에 버티니까 존속할 수 있다. 하지만 진화할 수 없다. 단기적으로 이익이 되는 불투명함이 궁극적 종말의 씨앗을 뿌린다.

진흙투성이가 치명적이라면, 이게 정말 나쁜 걸까? 굳어버린 시스템이 더 민첩한 후계자에게 무대를 내주는 것이 축복일 수 있다.

시스템을 버리면 구현은 사라지고 개념적 설계만 남는다. 밑의 패턴만 남아, 체셔 고양이처럼 미소 짓는다. 그 정신이 다음 구현을 빚는다. 운이 좋으면 아키텍처 통찰이 새 시스템에서 추상 클래스와 framework로 다시 태어난다.

버리고 다시 시작하는 대안도 있다. 점진적 refactoring으로 수렁에서 아키텍처 요소를 뽑아내는 것이다. 시스템의 전부 또는 일부를 대체할 새 컴포넌트와 framework가 나왔는지 다시 살피는 것이다.

Brooks는 이렇게 봤다. 건축가가 설계할 가장 위험한 시스템은 두 번째 시스템이다. 악명 높은 [SecondSystemEffect](http://wiki.c2.com/?SecondSystemEffect)(두 번째 시스템 효과)다. RECONSTRUCTION은 이 잘못 놓인 자만심이 발휘될 기회를 준다. 경계를 게을리하면 안 된다. 그래도 버리고 다시 시작하는 게 최선이자 유일한 방법인 경우가 있다.

Brooks의 고전적 훈계를 새긴다. **"하나를 버릴 계획을 세워라. 어차피 그렇게 될 것이다(plan to throw one away, you will anyway)."**

### Conclusion

소프트웨어 아키텍처는 경험을 지혜로 뽑아내고 퍼뜨리는 일이다. 이 패턴들을 안티패턴으로 보지 않는다. 좋은 프로그래머가 BIG BALLS OF MUD를 만드는 데는 그럴 만한 이유가 있다. 시장이 너무 빨리 움직여서 장기적 아키텍처 야심이 어리석은 상황이 있다. 일회용 프로그래밍이 최첨단 전략인 상황이 있다. 이 접근법의 성공은 부인할 수 없다. 사람들이 BIG BALLS OF MUD를 만드는 이유는 **돌아가기 때문이다**. 많은 도메인에서 돌아가는 것으로 검증된 유일한 것이다.

BIG BALLS OF MUD를 탓하려는 게 아니다. 시스템 진화 초기에 격식 없는 아키텍처는 자연스럽다. 하지만 더 잘할 수 있기를 바란다. 쇠퇴로 이끄는 힘과 압력을 알아야 한다. 언제 어떻게 맞설 수 있는지 알면, 오래가는 산물의 무대를 마련할 수 있다. 핵심이 있다. 시스템, 프로그래머, 조직이 도메인과 아키텍처 기회에 대해 자라면서 배우는 것이다.

적당한 무질서는 소프트웨어 진화의 밀물과 썰물이다. 마스터 셰프가 지저분한 주방을 참듯, 개발자는 새 영역을 탐험할 때 진흙을 두려워하지 말아야 한다. 아키텍처 통찰은 마스터플랜이 아니라 힘겹게 얻은 경험의 산물이다.

과거에는 RECONSTRUCTION이 평범한 시스템을 대체하는 유일한 방법인 경우가 많았다. 객체, framework, 컴포넌트, refactoring 도구가 또 다른 길을 열어준다. 객체는 거친 애플리케이션과 저수준 코드 사이에서 아키텍처 아이디어를 표현하는 매체다. Refactoring 도구와 기법은 산물이 진화하면서 통찰을 잡아두는 수단을 준다.

> *모스크바 Kremlin 성벽 바로 바깥에 성 바실리 성당이 있다. 러시아의 가장 유명한 랜드마크 중 하나다. 1552년에 타타르 격퇴를 기념하기 위해 Ivan 4세가 건축했다. 전설에 의하면 "이반 뇌제"라는 별명의 Ivan은 완공 후 건축가를 눈멀게 했다. 다시는 더 아름다운 것을 짓지 못하게 하려는 것이었다. 안타깝게도 오늘날 소프트웨어 아키텍처의 상태는, 우리 중 누구도 시력을 걱정할 필요가 없을 정도다.*

### Acknowledgments

많은 사람이 이 논문이 중심 주제의 의도치 않은 실례가 되지 않도록 도왔다. University of Illinois Software Architecture Group의 멤버들에게 감사한다. John Brant, Ian Chai, Ralph Johnson, Lewis Muir, Dragos Manolescu, Brian Marick, Eiji Nabika, John (Zhijiang) Han, Kevin Scheufele, Tim Ryan, Girish Maiya, Weerasak Wittawaskul, Alejandra Garrido, Peter Hatch, Don Roberts. shepherd Bobby Woolf, PLoP '97 Writer's Workshop 멤버들, Brad Appleton과 Chicago Patterns Group, Steve Berczuk과 Boston Area Patterns Group, Joshua Kerievsky와 New York City Design Patterns Study Group, Sydney Patterns Group의 Paolo Cantoni 등에게도 감사한다. John Vlissides, Neil Harrison, Hans Rohnert, James Coplien, Ralph Johnson이 솔직하고 유용한 비평을 해줬다.

### References (선별)

- [Alexander 1964] Christopher Alexander, *Notes on the Synthesis of Form*, Harvard University Press, 1964
- [Alexander 1979] Christopher Alexander, *The Timeless Way of Building*, Oxford University Press, 1979
- [Alexander et al. 1977] C. Alexander, S. Ishikawa, M. Silverstein, *A Pattern Language*, Oxford University Press, 1977
- [Beck 1997] Kent Beck, *Smalltalk Best Practice Patterns*, Prentice Hall, 1997
- [Beck 2000] Kent Beck, *Embracing Change: Extreme Programming Explained*, Cambridge University Press, 2000
- [Brand 1994] Stewart Brand, *How Buildings Learn: What Happens After They're Built*, Viking Press, 1994
- [Brooks 1995] Frederick P. Brooks, Jr., *The Mythical Man-Month (Anniversary Edition)*, Addison-Wesley, 1995
- [Brown et al. 1998] William J. Brown et al., *Antipatterns: Refactoring, Software Architectures, and Projects in Crisis*, Wiley, 1998
- [Buschmann et al. 1996] Frank Buschmann et al., *Pattern-Oriented Software Architecture: A System of Patterns*, John Wiley and Sons, 1996
- [Coplien 1995] James O. Coplien, *A Generative Development-Process Pattern Language*, in *Pattern Languages of Program Design*, Addison-Wesley, 1995
- [Fowler 1999] Martin Fowler, *Refactoring: Improving the Design of Existing Code*, Addison Wesley Longman, 1999
- [Gabriel 1991] Richard P. Gabriel, *Lisp: Good News Bad News and How to Win Big*
- [Gamma et al. 1995] Erich Gamma et al., *Design Patterns: Elements of Reusable Object-Oriented Software*, Addison-Wesley, 1995
- [Simon 1969] Herbert A. Simon, *The Sciences of the Artificial*, MIT Press, 1969

---

## wiki.c2.com 커뮤니티 토론

### BrianFoote의 관점

> [MichaelFeathers](http://wiki.c2.com/?MichaelFeathers)가 [SystemsAsLivingThings](http://wiki.c2.com/?SystemsAsLivingThings), [WorseIsBetter](http://wiki.c2.com/?WorseIsBetter), [YouArentGonnaNeedIt](http://wiki.c2.com/?YouArentGonnaNeedIt) 사이의 공통점에 "[ReactiveDevelopment](http://wiki.c2.com/?ReactiveDevelopment)"라는 이름을 제안했다.

BrianFoote는 "reactive"가 좀 수동적이라고 느꼈다. 대신 **기회주의적(Opportunistic)** 접근을 선호한다고 답했다.

> 아키텍처를 미리 잡으려 하지 않는다. 공통점이 분명해질 때 뽑아낸다. Refactoring으로 떠오르는 추상화에 독립적 정체성을 준다. 기회를 잡아 시스템을 더 재사용 가능하고, 범용적이며, 이해하기 쉽게 만든다.

> [YouArentGonnaNeedIt](http://wiki.c2.com/?YouArentGonnaNeedIt)은 약간의 "[CreativeStupidity](http://wiki.c2.com/?CreativeStupidity)"를 쓴다. 자기가 생각하는 만큼 똑똑하지 않은 척하라. 똑똑한 아이디어가 정말 필요할 때까지 기다려라. 맞았으면 오는 걸 봤으니 뭘 할지 안다. 틀렸으면 아무도 원하지 않는 "투기 주택"을 허물 필요가 없다.

> 생명주기 후반에 통찰을 통합하는 건 마스터 플래닝보다 **더 보수적인 전략**이다. 아키텍처 혁신을 예지(foresight)가 아닌 후지(hindsight)로 이끌기 때문이다. 이게 먹히려면 관리자가 설계가 생명주기 전체에 스며든다는 걸 인정해야 한다. Refactoring이 더 나은 객체의 진화를 이끈다는 것도 인정해야 한다.
>
> -- [BrianFoote](http://wiki.c2.com/?BrianFoote)

### MichaelFeathers의 관점

> "reactive"를 부정적으로 쓴 것이 아니었다. 시스템 성장이 정교하게 계획되기보다 환경에 반응하여 일어난다는 뜻이었다.

> 노력을 안 들이면 소프트웨어가 BIG BALL OF MUD가 된다는 사실을 활용할 수 있지 않을까? 자연적 과정을 유리하게 쓸 수 있지 않을까? 미친 소리로 들리겠지만, 정교한 소프트웨어에 필요한 구조의 양을 최소화할 수 있다면, 엔트로피 공격에 더 잘 버티는 걸 가질 수 있지 않을까?
>
> -- [MichaelFeathers](http://wiki.c2.com/?MichaelFeathers)

Foote는 이에 답했다. 최소 구조가 설계 공간 탐색에는 좋다. 하지만 잘 다져진 길이 잡히면서 구조가 나타난다. "구조 최소화"가 구조를 만드는 데 드는 **작업과 장부 기록의 양**을 줄인다는 뜻이라면 동의한다. Lisp과 Smalltalk에서 반복적/진화적 프로그래밍이 당연한 반면 C++에서는 그렇지 않은 이유가 있다. 이들 언어에서는 refactoring할 때 선언을 고칠 곳이 더 적다. 혼잡에서 구조를 뽑아내기가 더 쉽다.

### JeffGrigg의 관점

> 전통적 개발 방법론의 핵심 실패는 refactoring이 없다는 것이다. 그게 없으면 어떤 시스템이든, 초기에 아무리 잘 설계됐더라도, 유지보수하면서 시간이 지나면 구조를 잃는다.

> 시스템 구조가 어쩔 수 없이 나빠져서 결국 재작성해야 한다는 공식 발표를 본 적 있다. 나는 그걸 안 믿는다. 시스템은 시간이 지나면서 아키텍처를 개선하도록 refactoring할 수 있다. 비즈니스의 기본 운영 모델이 바뀌거나 컴퓨팅 기술을 갈아야 하는 경우가 아니라면, 품질이 나빠져야 할 이유가 없다.

> 아무도 refactoring을 개발이나 유지보수의 일부로 가르치지 않는다. 대부분의 방법론은 시스템 인도로 끝나는 "생명주기"를 그린다. 끝에 유지보수는 같은 방식을 더 작은 주기로 한다는 코멘트를 붙인다. 처음에 올바르게 될 거라 가정한다. 변경은 필요 없다고 가정한다. ***절대로!*** 이건 진실과 거리가 멀다.

> 일부 극단주의자(extreme-ists)는 항상 refactoring해서 설계 방식 자체로 삼을 수 있다. [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)을 안 하더라도, 구식 방법론을 쓰는 프로젝트도 refactoring의 가치를 배워야 한다.
>
> -- [JeffGrigg](http://wiki.c2.com/?JeffGrigg)

### FutureDiscounting과 refactoring

익명 기여자는 [FutureDiscounting](http://wiki.c2.com/?FutureDiscounting)이 과도한 refactoring에 불리하게 작용한다고 주장했다. 어차피 언어를 버리고 새 것으로 갈아탈 텐데, 왜 refactoring에 신경 쓰느냐는 것이다.

[LlewelynThomas](http://wiki.c2.com/?LlewelynThomas)는 반박했다.

> "나는 대부분이 절차적 코드라 할 것을 작성한다. 긴밀하고, 빠르고, 작다. 하지만 매 변경 시 refactoring하지 않으면 유지보수가 불가능해진다. 내 refactoring이 코드를 긴밀하고, 빠르고, 작게 **유지시킨다**."

또 다른 기여자(nn)는 명확히 했다.

> "[FutureDiscounting](http://wiki.c2.com/?FutureDiscounting)은 아직 모르는 미래 요구사항을 위해 투기적으로 refactoring할 때만 해당한다. 이미 알려진 요구사항을 충족하기 위한 refactoring은 XP 진영과 Martin Fowler의 *Refactoring*이 권하는 종류다."

> "개인적으로 refactoring이 처음부터 코딩하는 것보다 '올바르게 만들기' 쉽다. 잘 나뉜 프로그램을 새 언어로 옮기는 건 쉽다. 처음부터 쓰면 새 버그가 들어오기 쉽다."

---

## 키워드

big ball of mud, architecture, entropy, piecemeal growth, refactoring, shearing layers, throwaway code, software evolution, Conway's Law, extreme programming

## 관련 문서

- [WhatIsSoftwareDesign](what-is-software-design.md) — Jack Reeves의 "소스 코드가 곧 설계" 논문. 설계가 코딩 과정에서 발현된다는 통찰.
- [NoSilverBullet](no-silver-bullet.md) — Brooks의 본질적/부수적 복잡성 구분. BIG BALL OF MUD가 왜 불가피한지의 이론적 배경.
- [SystemsAsLivingThings](http://wiki.c2.com/?SystemsAsLivingThings)
- [WorseIsBetter](http://wiki.c2.com/?WorseIsBetter)
- [YouArentGonnaNeedIt](http://wiki.c2.com/?YouArentGonnaNeedIt)
- [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)
- [FutureDiscounting](http://wiki.c2.com/?FutureDiscounting)
- [RefactorLowHangingFruit](http://wiki.c2.com/?RefactorLowHangingFruit)
- [SpaghettiCode](http://wiki.c2.com/?SpaghettiCode)
