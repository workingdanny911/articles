---
source: http://wiki.c2.com/?WhatIsSoftwareDesign
original_source: http://www.bleading-edge.com/Publications/C++Journal/Cpjour2.htm
original_author: Jack Reeves
original_date: "1992"
title: WhatIsSoftwareDesign
contributors: [MichaelFeathers, RonJeffries, RalphJohnson, KrisJohnson, HowardFear, JackReeves, WayneMack, DougKing, MattMoran, BernhardPollak]
accessed: 2026-02-08
category: foundations
keywords: [software design, source code, Jack Reeves, engineering, code as design, manufacturing]
summary: "소스 코드가 곧 설계다 — Jack Reeves의 통찰과 wiki.c2.com 커뮤니티의 토론"
---

# 소프트웨어 설계란 무엇인가

Jack Reeves는 1992년 C++ Journal에 기고한 에세이에서 핵심을 짚었다. **소스 코드가 곧 소프트웨어 설계다.** 컴파일러와 링커가 소프트웨어를 "제조"한다. 프로그래밍은 구현이 아니라 설계 활동이다. 이 글은 waterfall 모델의 전제를 뒤집었다. [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)의 실천을 이론으로 뒷받침하는 선구적 에세이다.

---

## Jack Reeves의 원본 에세이 (1992)

> **What Is Software Design?**
> by Jack W. Reeves
> &copy;C++ Journal - 1992

객체지향 기법, 특히 C++이 소프트웨어 세계를 휩쓸고 있다. 새 기법을 어떻게 쓰는지 설명하는 글과 책이 쏟아졌다. "객체지향은 과대광고인가?"라는 물음은 "어떻게 하면 적은 비용으로 이점을 얻는가?"로 바뀌었다. 객체지향 자체는 꽤 오래된 기법이다. 이 폭발적 인기는 좀 이례적이다.

왜 갑자기 관심이 쏠렸을까? 여러 설명이 있지만 딱 하나의 원인은 없다. 여러 요인이 임계질량에 도달한 것이다. 그중 C++ 자체가 핵심 요인이다. 이유야 여럿이겠지만, 나는 조금 다른 관점을 내놓겠다. **C++이 인기를 얻은 이유는 설계와 프로그래밍을 동시에 하기 쉽게 만들었기 때문이다.**

좀 독특하게 들린다면 의도한 것이다. 이 글에서 나는 프로그래밍과 소프트웨어 설계의 관계를 살펴본다. 거의 10년간 느낀 것이 있다. 소프트웨어 산업이 미묘한 차이를 놓치고 있다. "설계를 만드는 것"과 "설계가 실제로 무엇인지"의 차이다. C++의 인기 속에는 더 나은 소프트웨어 엔지니어가 되기 위한 깊은 교훈이 있다. **프로그래밍은 소프트웨어를 만드는 것이 아니다. 설계하는 것이다.**

수년 전, 소프트웨어 개발이 engineering인지 묻는 세미나에 간 적이 있다. 논의 내용은 기억나지 않는다. 다만 그때부터 생각이 시작됐다. 소프트웨어 산업은 하드웨어 engineering과 잘못된 비유를 만들었다. 정작 맞는 비유는 놓치고 있었다. 결론은 이것이다. 소프트웨어 설계가 진짜 무엇인지 모르기 때문에, 우리는 아직 소프트웨어 엔지니어가 아니다. 오늘날 그 확신은 더 강하다.

**모든 engineering 활동의 최종 목표는 어떤 형태의 문서다.** 설계가 끝나면 설계 문서를 제조팀에 넘긴다. 제조팀은 설계팀과 기술이 완전히 다른 사람들이다. 설계 문서만 충분하면 제조팀은 제품을 만들 수 있다. 설계자가 더 관여하지 않아도 많은 제품을 만들 수 있다. 오늘날 소프트웨어 개발 생명주기를 돌아보자. engineering 설계 기준을 충족하는 문서는 하나뿐이다. **소스 코드다.**

이 전제에 찬성하거나 반대하는 논거는 수없이 많다. 이 글에서는 소스 코드가 진짜 소프트웨어 설계라고 가정하고 그 결과를 살펴본다. 이 관점이 옳다고 증명할 수는 없을지 모른다. 하지만 C++의 인기를 포함해 소프트웨어 산업에서 관찰되는 사실들을 설명할 수 있기를 바란다.

### 소프트웨어는 만들기가 거의 공짜다

코드를 설계로 보면 하나의 결과가 다른 모든 것을 압도한다. 너무 중요하고 너무 뻔해서 대부분의 조직이 완전히 놓치고 있다. **소프트웨어는 만들기가 싸다.** 저렴한 정도가 아니다. 거의 공짜다.

소스 코드가 설계라면, 소프트웨어를 실제로 만드는 건 컴파일러와 링커다. 시스템 전체를 컴파일하고 링크하는 과정을 "빌드"라 부른다. 장비 투자도 별것 아니다. 컴퓨터, 에디터, 컴파일러, 링커만 있으면 된다. 빌드 환경만 갖춰지면 실제 빌드는 잠깐이면 끝난다.

50,000줄짜리 C++ 프로그램을 컴파일하면 영원처럼 느껴질 수 있다. 하지만 같은 복잡도의 하드웨어 시스템을 만드는 데는 얼마나 걸릴까?

### 설계는 쉽게 만들어지고, 그래서 거대해진다

소스 코드를 설계로 보면 또 하나 알 수 있다. 소프트웨어 설계는 물리적으로 만들기가 꽤 쉽다. 50~100줄짜리 모듈을 쓰는 데 보통 이틀이면 된다. 디버깅까지 끝내는 건 별개지만, 만들기 자체는 빠르다. 그래서 소프트웨어 설계는 아주 빠르게 거대해진다.

만들기 쉽고 빌드가 공짜이니, 결과는 뻔하다. **소프트웨어 설계는 말도 안 되게 크고 복잡해진다.** 학교 프로젝트도 수천 줄이 된다. 만 줄짜리 설계를 무료로 배포하는 개발자도 있다. 단순한 소프트웨어가 관심을 끌던 시대는 오래전에 끝났다. 상용 소프트웨어 설계는 수십만 줄에 이른다. 수백만 줄도 드물지 않다. 게다가 소프트웨어 설계는 거의 항상 진화한다. 지금 수천 줄이어도, 제품 수명 동안 작성되는 코드는 그 몇 배가 될 수 있다.

### 하드웨어도 완벽하지 않다

소프트웨어만큼 복잡한 하드웨어 설계도 물론 있다. 하지만 현대 하드웨어에 대해 두 가지를 짚어야겠다.

첫째, 복잡한 하드웨어 engineering도 항상 버그 없이 나오지는 않는다. 논리 오류가 있는 마이크로프로세서가 출하됐다. 다리가 무너졌다. 댐이 터졌다. 여객기가 추락했다. 수천 대의 자동차가 리콜됐다. 모두 최근 일이고, 모두 설계 오류 때문이다.

둘째, 복잡한 하드웨어 설계에는 그만큼 비용과 시간이 드는 빌드 단계가 있다. 제조 능력 때문에 복잡한 하드웨어를 만들 수 있는 회사 수가 제한된다. 소프트웨어에는 그런 제한이 없다. 수백 개의 소프트웨어 조직이 있고, 수천 개의 매우 복잡한 소프트웨어 시스템이 돌아가고 있다. 수와 복잡도 모두 날마다 늘어난다.

소프트웨어 산업이 하드웨어 개발자를 따라 해서는 답을 찾기 어렵다. 오히려 CAD와 CAM 시스템 덕분에 **하드웨어 engineering이 소프트웨어 개발을 닮아가고 있다.**

### 복잡성 관리로서의 소프트웨어 설계

소프트웨어를 설계한다는 건 복잡성을 관리하는 일이다. 복잡성은 설계 자체에도, 조직에도, 산업 전체에도 있다. 소프트웨어 설계는 시스템 설계와 비슷하다. 여러 기술에 걸치고 여러 하위 분야를 포함한다. 명세는 유동적이다. 설계 도중에도 빠르게 변한다. 개발팀도 마찬가지다. 설계 중간에 바뀌기도 한다.

여러 면에서 소프트웨어는 하드웨어보다 복잡한 사회적, 유기적 시스템에 가깝다. 이 모든 것이 소프트웨어 설계를 어렵고 실수가 잦은 과정으로 만든다. 새로운 이야기는 아니다. 소프트웨어 engineering 혁명이 시작된 지 거의 30년이 지났다. 그런데도 소프트웨어 개발은 다른 engineering 분야에 비해 덜 성숙한 기예로 평가받는다.

### 테스트와 디버깅은 설계 활동이다

실제 엔지니어는 설계를 마치면 작동할 거라고 꽤 확신한다. 그 확신을 얻기 위해 상당한 시간을 들여 설계를 검증하고 다듬는다. 다리 설계를 생각해보자. 건설 전에 구조 분석을 하고, 컴퓨터 모델로 시뮬레이션을 돌리고, 축소 모형을 풍동에서 테스트한다. 설계가 괜찮은지 확인하려고 할 수 있는 건 다 한다. 비행기는 더하다. 실물 크기 시제품을 만들어 시험 비행까지 해야 한다.

소프트웨어 설계는 이런 수준의 엄격한 engineering을 거치지 않는다고 흔히들 생각한다. 하지만 소스 코드를 설계로 보면 이야기가 달라진다. 소프트웨어 설계자도 상당한 검증과 개선을 한다. 다만 이걸 engineering이라 부르지 않을 뿐이다. **테스트와 디버깅이라 부른다.** 대부분 테스트와 디버깅을 "진정한 engineering"으로 보지 않는다. 소프트웨어 산업이 코드를 설계로 인정하길 거부하기 때문이다. 실제 engineering적 차이 때문이 아니다. 모형과 시제품은 다른 engineering 분야에서도 당연히 인정받는 과정이다.

**핵심은 이것이다. 그냥 빌드해서 테스트하는 게 다른 어떤 방법보다 싸고 간단하다.** 빌드를 몇 번 하든 상관없다. 시간은 거의 안 들고, 빌드를 폐기하면 자원을 회수할 수 있다. 테스트는 현재 설계를 바로잡을 뿐 아니라 더 낫게 만드는 과정이기도 하다. 하드웨어 엔지니어가 모형을 만들어 설계의 "감"을 잡듯이, 소프트웨어 설계자는 제품 자체를 빌드한다. 형식적 검증(formal verification)이 컴파일러만큼 자동화되더라도 빌드/테스트 사이클은 여전히 필요하다. 형식적 검증이 소프트웨어 산업에서 큰 주목을 받지 못한 이유다.

### 현재 프로세스의 문제

오늘날 현실은 이렇다. 점점 더 복잡한 소프트웨어 설계를, 점점 더 많은 사람과 조직이 만들고 있다. 이 설계들은 프로그래밍 언어로 코딩된 뒤, 빌드/테스트 사이클로 검증되고 다듬어진다. 이 과정은 실수가 잦고 그다지 엄격하지도 않다. 많은 소프트웨어 개발자가 이 현실을 받아들이지 않으려 한다. 그게 문제를 더 키운다.

대부분의 소프트웨어 개발 프로세스는 설계 단계를 별도 칸에 가둔다. 상위 설계를 끝내고 동결한 뒤에야 코드를 작성한다. 테스트와 디버깅은 구현상 실수를 걸러내는 용도일 뿐이다. 그 사이에 프로그래머가 있다. 소프트웨어 산업의 "건설 노동자"다. 프로그래머가 "해킹"을 멈추고 주어진 설계대로 "빌드"하면 된다고 많은 사람이 믿는다. 그래야 소프트웨어 개발이 진정한 engineering으로 성숙한다고 본다. engineering과 경제의 현실을 무시하면 결코 이뤄지지 않는다.

예를 들어보자. 제조 공정에서 100% 이상의 재작업률을 용납하는 산업은 없다. 처음부터 못 만드는 건설 노동자는 곧 일자리를 잃는다. 소프트웨어는 다르다. 아무리 작은 코드 조각도 테스트와 디버깅 중에 수정되거나 완전히 다시 쓰일 수 있다. 설계라는 창조적 과정에서는 이런 개선이 당연하다. 제조 과정에서는 그렇지 않다. 엔지니어가 첫 시도에서 완벽한 설계를 내놓으리라 기대하는 사람은 없다. 완벽하더라도 개선 과정을 거쳐 증명해야 한다.

일본식 관리 기법의 핵심 교훈은 분명하다. 프로세스의 잘못을 노동자 탓으로 돌리는 건 비생산적이다. 잘못된 프로세스 모델에 소프트웨어 개발을 끼워 맞추면 안 된다. **더 나은 소프트웨어를 만드는 방향으로 프로세스를 고쳐야 한다.** 이것이 "소프트웨어 engineering"의 리트머스 테스트다. engineering은 프로세스를 어떻게 하느냐의 문제다. 최종 설계 문서에 CAD가 필요한지의 문제가 아니다.

### 모든 것이 설계 과정의 일부다

**소프트웨어 개발에서 정말 큰 문제는 모든 것이 설계 과정의 일부라는 점이다.** 코딩이 설계다. 테스트와 디버깅도 설계의 일부다. 흔히 "소프트웨어 설계"라 부르는 것도 여전히 설계의 일부다. 소프트웨어는 빌드하기엔 싸지만 설계하기엔 엄청나게 비싸다.

소프트웨어는 매우 복잡하다. 다양한 설계 측면과 뷰가 있다. 문제는 이 측면들이 서로 얽혀 있다는 것이다. 상위 설계자가 모듈 알고리즘의 세부를 무시할 수 있으면 좋겠다. 프로그래머가 상위 설계를 신경 쓰지 않아도 되면 좋겠다. 하지만 한 설계 레이어의 측면은 다른 레이어로 번진다. 모듈의 알고리즘 선택이 상위 설계만큼 중요할 수 있다.

**소프트웨어 설계의 각 측면 사이에 중요도 위계는 없다.** 가장 낮은 모듈 수준의 잘못된 설계도 가장 높은 수준의 실수만큼 치명적이다. 소프트웨어 설계는 모든 측면에서 완전하고 정확해야 한다. 그렇지 않으면 그 설계로 빌드한 모든 것에 오류가 생긴다.

### 설계는 코딩과 테스트를 거쳐야 완성된다

**소프트웨어 설계는 코딩하고 테스트하기 전까지는 완성되지 않는다.** 테스트는 설계를 검증하고 다듬는 근본 과정이다. 상위 구조 설계는 완전한 소프트웨어 설계가 아니다. 상세 설계를 위한 구조적 틀일 뿐이다. 상위 설계를 엄격히 검증할 수 있는 능력은 매우 제한적이다.

상세 설계는 결국 상위 설계에 큰 영향을 미친다. 그래야 한다. 모든 측면의 개선은 설계 사이클 전체에 걸쳐 일어나야 한다. 어떤 측면이든 중간에 동결하면, 최종 설계가 나빠지거나 아예 작동하지 않는 건 당연하다.

상위 설계가 더 엄격한 engineering이면 좋겠다. 하지만 현실은 그렇지 않다. 소프트웨어는 너무 복잡하고 너무 많은 것에 의존한다. 하드웨어가 예상과 다르게 작동할 수 있다. 라이브러리 루틴에 문서에 없는 제약이 있을 수 있다. 모든 소프트웨어 프로젝트가 조만간 부딪히는 문제다.

테스트 중에 발견되는 이유는 간단하다. 더 일찍 발견할 방법이 없었기 때문이다. 발견되면 설계를 바꿔야 한다. 운이 좋으면 변경은 국소적이다. 더 흔하게는 전체 설계로 퍼진다. 영향받은 부분을 바꿀 수 없으면, 다른 부분을 약화시켜 수용해야 한다. 관리자들은 이걸 "해킹"이라 본다. 하지만 이것이 소프트웨어 개발의 현실이다.

기예와 engineering의 차이가 여기 있다. 경험이 올바른 방향으로 이끌어줄 수 있다. 이것이 기예다. 하지만 경험만으로는 모르는 영역에서 한계가 있다. 처음 만든 것을 체계적인 개선 과정으로 더 낫게 만들어야 한다. 이것이 engineering이다.

작은 점 하나. 모든 프로그래머가 안다. 설계 문서는 코드 전이 아니라 코드 후에 쓰면 훨씬 정확하다. 이유는 분명하다. 빌드/테스트 사이클에서 개선되는 유일한 설계는 코드에 반영된 최종 설계뿐이기 때문이다. 초기 설계가 이 사이클에서 안 바뀔 확률은 모듈 수와 프로그래머 수에 반비례한다. 빠르게 0에 수렴한다.

### 우리에게 필요한 것

소프트웨어 engineering에서 모든 수준의 좋은 설계가 절실하다. 특히 좋은 상위 설계가 필요하다. 초기 설계가 좋을수록 상세 설계가 쉬워진다. 설계자는 도움이 되는 건 뭐든 쓰면 된다. Structure chart, Booch diagram, 상태 표, PDL 등 도움이 되면 쓰라.

하지만 명심할 것이 있다. 이런 도구와 표기법은 소프트웨어 설계가 아니다. 결국 진짜 소프트웨어 설계를 만들어야 한다. 어떤 프로그래밍 언어로 된 것을. 설계를 만들어가면서 코딩하는 걸 두려워할 필요 없다. 필요하면 고치겠다는 의지만 있으면 된다.

아직 상위 설계와 상세 설계에 모두 잘 맞는 표기법은 없다. 설계는 결국 프로그래밍 언어로 코딩된다. 상위 설계 표기법을 대상 언어로 변환해야 상세 설계를 시작할 수 있다. 변환에는 시간이 걸리고 실수가 생긴다. 대상 언어에 깔끔하게 맞지 않는 표기법이라면? 프로그래머들은 차라리 요구사항으로 돌아간다. 상위 설계를 코딩하며 다시 하는 것이다. 이것도 소프트웨어 개발의 현실이다.

여기서 C++이 등장한다. C++은 실제 프로젝트에 쓸 수 있는 프로그래밍 언어이면서 더 표현력 있는 설계 언어다. 설계 구성요소의 상위 수준 정보를 직접 표현할 수 있다. 설계를 만들기 쉽게 하고 나중에 고치기도 쉽게 한다. 더 강한 type checking으로 설계 오류를 잡아주기도 한다. 결과적으로 더 견고한 설계, 더 잘 engineering된 설계가 나온다.

### 소프트웨어 산업의 집단 무의식

결국 소프트웨어 설계는 어떤 프로그래밍 언어로 표현된다. 그리고 빌드/테스트 사이클로 검증되고 다듬어진다. 그 외의 척은 허세에 불과하다. 소프트웨어 개발 도구와 기법 중 실제로 인기를 얻은 것을 떠올려보자. 구조적 프로그래밍은 당시 혁신이었고, Pascal이 대중화했다. 객체지향 설계는 새로운 흐름이고, C++이 그 중심이다. 반면 뭐가 성공하지 못했나? CASE 도구, Structure chart, Warner-Orr diagram, Booch diagram, 객체 다이어그램. 각각 장점은 있지만, 근본적 약점이 하나 있다. 진짜 소프트웨어 설계가 아니라는 것이다. 소프트웨어 설계 표기법 중 유일하게 널리 퍼진 건 PDL인데, 그건 코드와 거의 같다.

소프트웨어 산업의 집단 무의식은 본능적으로 안다. 프로그래밍 기법의 개선, 특히 프로그래밍 언어의 개선이 다른 무엇보다 중요하다는 것을. 더 표현력 있는 언어가 나오면 개발자들은 채택한다.

소프트웨어 개발 프로세스의 변화도 생각해보자. 한때 waterfall이 있었다. 지금은 spiral 개발과 rapid prototyping을 이야기한다. 이런 기법이 "리스크 완화"나 "출시 시간 단축"으로 정당화되곤 한다. **사실은 생명주기에서 더 일찍 코딩을 시작하려는 구실이다.** 좋은 일이다. 빌드/테스트 사이클이 더 일찍 설계를 검증하고 다듬을 수 있게 해준다. 상위 설계를 만든 설계자가 아직 팀에 남아서 상세 설계까지 할 가능성도 높아진다.

### 보조 문서

engineering은 프로세스를 어떻게 하느냐의 문제다. 최종 제품의 모습이 아니다. 프로그래밍과 빌드/테스트 사이클이 소프트웨어 engineering의 중심이다. 모든 설계 프로젝트의 목표가 설계 문서를 만드는 것이지만, 그것만이 필요한 문서는 아니다. 누군가 소프트웨어를 쓸 것이고, 나중에 고치고 개선해야 할 것이다. 보조 문서에는 두 가지 중요한 쓰임이 있다.

첫째, 설계에 직접 반영되지 않은 문제 영역의 정보를 담는 것이다. 소프트웨어 설계란 문제 공간의 개념을 모델링하려고 소프트웨어 개념을 만들어내는 일이다. 이 과정에서 직접 모델링되지는 않지만, 핵심 개념을 판단하는 데 도움이 된 정보가 생긴다. 나중에 모델을 바꿀 때를 대비해 이 정보를 기록해둬야 한다.

둘째, 설계 자체에서 바로 읽어내기 어려운 측면을 기록하는 것이다. 상위 수준과 하위 수준 모두 해당한다. 이런 측면 중 많은 것이 그래픽으로 표현하기에 적합하다. 소스 코드 주석에 넣기는 어렵다. 그렇다고 그래픽 표기법이 프로그래밍 언어를 대체해야 한다는 뜻은 아니다. 하드웨어 분야에서도 그래픽 설계 문서에 텍스트 설명이 따라오는 것과 같다. 소스 코드가 실제 설계를 결정한다는 점을 잊으면 안 된다. 보조 문서가 아니다.

이상적으로는 소스 코드를 처리해 보조 문서를 뽑아주는 도구가 있으면 좋겠다. 그게 어렵다면, 프로그래머가 소스 코드에서 정보를 뽑아 다른 방식으로 정리하는 도구가 차선이다. 수동으로 유지하기는 어렵다. 더 표현력 있는 프로그래밍 언어가 필요한 또 다른 이유다. 보조 문서는 가능한 한 늦게까지 최소한으로 유지해야 한다는 근거이기도 하다.

### 요약

- 실제 소프트웨어는 컴퓨터에서 실행된다. 자기 매체에 저장된 0과 1이다. C++ 프로그램 목록이 아니다.
- 프로그램 목록은 소프트웨어 설계를 나타내는 문서다. 컴파일러와 링커가 실제로 소프트웨어를 빌드한다.
- 소프트웨어는 빌드하기에 매우 싸다. 컴퓨터가 빨라질수록 더 싸진다.
- 소프트웨어는 설계하기에 매우 비싸다. 복잡하고, 거의 모든 단계가 설계 과정의 일부이기 때문이다.
- 프로그래밍은 설계 활동이다. 좋은 설계 프로세스는 이걸 알고, 코딩이 합리적일 때 주저하지 않는다.
- 코딩이 합리적인 경우는 생각보다 많다. 설계를 코드로 옮기면 간과한 부분과 추가 설계의 필요성이 드러난다. 일찍 드러날수록 좋다.
- 소프트웨어 빌드가 매우 싸므로, 형식적 검증은 큰 쓸모가 없다. 증명하려 하기보다 빌드하고 테스트하는 게 더 쉽고 싸다.
- 테스트와 디버깅은 설계 활동이다. 다른 engineering 분야의 설계 검증과 개선에 해당한다. 줄여서는 안 된다.
- 상위 설계, 모듈 설계, 구조 설계, 아키텍처 설계 등 다른 설계 활동도 있다. 좋은 설계 프로세스는 이걸 알고 의도적으로 포함한다.
- 모든 설계 활동은 서로 영향을 준다. 좋은 설계 프로세스는 이걸 알고, 필요하면 과감한 변경도 허용한다.
- 다양한 소프트웨어 설계 표기법이 쓸모 있을 수 있다. 보조 문서로, 설계 프로세스를 돕는 도구로. 하지만 그것들은 소프트웨어 설계가 아니다.
- 소프트웨어 개발은 여전히 engineering보다 기예에 가깝다. 설계 검증과 개선이 충분히 엄격하지 않기 때문이다.
- 소프트웨어 개발의 진정한 발전은 프로그래밍 언어의 발전에 달려 있다. C++이 그 사례다. 더 나은 설계를 직접 지원하는 주류 언어이기에 인기가 폭발했다.
- C++은 올바른 방향의 한 걸음이다. 하지만 더 많은 발전이 필요하다.

---

## wiki.c2.com 토론

[TheSourceCodeIsTheDesign](http://wiki.c2.com/?TheSourceCodeIsTheDesign)도 참고하라.

### MichaelFeathers의 소개

> 수년 전, 소프트웨어 설계에 대한 생각을 완전히 바꿔놓은 글을 읽었다. [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)이 이걸 받아들이길 바란다. [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)이 경험적으로 완전히 검증하는 통찰이라고 보기 때문이다. 나에게 더없이 좋은 시기에 찾아왔다. 처음 읽었을 때, IEEE 소프트웨어 문서 표준으로 프로젝트를 사후 문서화하면서 초현실적인 waterfall 프로세스를 저주하고 있었다.
>
> 핵심은 이것이다. 소프트웨어 개발의 원래 *단계(phases)*가 정해졌을 때, **그것들은 완전히 틀렸다.** 요구사항, 설계, 구현, 테스트는 우리가 생각하는 것과 다르다. 설계는 코딩 전에만 하는 게 아니다. 구현은 코딩 행위가 아니다. 다른 engineering 분야에서 이것들이 실제로 뭔지 보면 알 수 있다.
>
> (에세이에서):
>
> > *모든 engineering 활동의 최종 목표는 문서를 만드는 것이다. 설계가 끝나면 설계 문서를 제조팀에 넘긴다. 설계팀과 다른 기술을 가진 다른 사람들이다. 설계 문서가 완전한 설계를 나타낸다면, 제조팀은 제품을 만들 수 있다. 오늘날의 소프트웨어 개발 생명주기를 보면, engineering 설계 기준을 충족하는 소프트웨어 문서는 소스 코드뿐이다.*
>
> 프로그래밍할 때 당신은 상세 설계를 하고 있다. 소프트웨어의 제조팀은 컴파일러나 인터프리터다. 소스는 소프트웨어가 무엇을 할지에 대한 유일한 완전한 명세다. 클래스 다이어그램의 예쁜 상자들은 설계가 아니다. 설계의 상위 수준 뷰일 뿐이다.
>
> 핵심 결론:
> - *소프트웨어는 컴퓨터에서 실행된다. 0과 1이다. 프로그램 목록이 아니다.*
> - *프로그램 목록은 설계를 나타내는 문서다. 컴파일러와 링커가 소프트웨어를 빌드(제조)한다.*
> - *소프트웨어는 빌드하기 매우 싸다. 버튼만 누르면 된다.*
> - *소프트웨어는 복잡하고 모든 단계가 설계 과정이므로 설계하기 비싸다.*
> - *프로그래밍은 설계 활동이다. 코딩이 합리적일 때 주저하지 않는다.*
> - *코딩이 합리적인 경우는 생각보다 많다. 설계를 코드로 옮기면 간과한 부분이 드러난다. 빨리 드러날수록 좋다.*
> - *테스트와 디버깅은 설계 활동이다. 다른 engineering 분야의 설계 검증과 개선에 해당한다. 줄여서는 안 된다.*
> - *형식적 검증은 빌드하고 테스트하는 것보다 비싸므로 큰 쓸모가 없다.*
>
> -- [MichaelFeathers](http://wiki.c2.com/?MichaelFeathers)

---

### 소스 코드는 "유일한 진실"인가?

> 이 페이지에 대해 오랫동안 마음에 걸린 게 있다. 이 글이 소스 코드가 **그** 설계라고 말한다고 생각하지 않는다. XP 진영이 그렇게 읽게 하려는 것처럼 보이지만. 이 글이 말하는 건 이것이다. 소스 코드라는 문서가 속하는 종류가 "설계"라는 것이다.

> *맞다. 하지만 그 이상이다. 소스 코드는 현실을 정확히 반영한다고 보장되는 **유일한** 문서다. 참이라고 알 수 있는 유일한 설계 문서다. 설계자의 생각, 꿈, 환상은 코드에 담긴 만큼만 실제다. UML의 수많은 그림도 코드에 담긴 만큼만 정확하다. 소스 코드는 다른 어떤 문서도 주장할 수 없는 방식으로 설계다. 한 가지 더. 어쩌면 왜곡은 글에 있는 게 아니라 읽는 쪽에 있을 수도 있다.* -- [RonJeffries](http://wiki.c2.com/?RonJeffries)

> 소스 코드에는 실행되지 않는 코드가 있을 수 있다. 거짓말인 변수명과 프로시저명이 있을 수 있다. 프로그래머의 의도를 파악하기에 좋은 방법은 아니다. 나에게 설계란 결정의 결과만이 아니다. 결정 자체와 그 이유이기도 하다. 코드가 그걸 분명히 보여줄 때도 있다. 하지만 대개는 그렇지 않다. -- [RalphJohnson](http://wiki.c2.com/?RalphJohnson)

> "The XXX Is The Design" 류의 페이지에 공통 문제가 있다. "design"이 명사이면서 동시에 동사다. 명사로서 "design"은 문서를 가리킬 수도, 문서 작성 과정을 가리킬 수도 있다. 소프트웨어를 검토하며 구성하는 정신적 모델일 수도, 타인에게 설명하기 위한 개념적 모델일 수도 있다. 사람들이 이 모든 의미를 혼동하고 있다. 어떤 맥락에서 "옳은" 것이 다른 맥락에서는 "틀리다". -- [KrisJohnson](http://wiki.c2.com/?KrisJohnson)

---

### HowardFear: 복잡성의 본질

> 이 글을 전에 읽은 적이 있다. 가장 중요한 요점에 동의한다. 하지만 한 부분에 이의가 있다:
>
> > *"소프트웨어 설계는 비교적 쉽게 만들어지고 빌드가 공짜이므로, 믿을 수 없이 크고 복잡해진다 ... 상용 소프트웨어 설계는 수십만 줄로 구성된다."*
>
> 내 경험으로는 사실이 아니다. 소프트웨어 개발의 상당 부분은 IT 애플리케이션이다. 해당 비즈니스에 맞춤화해야 하는 잘 알려진 문제의 솔루션이다. 거의 모든 웹 애플리케이션이 해당한다.
>
> 소프트웨어 engineering의 문제는 소프트웨어를 개념적으로 복잡한 것처럼 다룬다는 점이다. 우리 대부분에게는 그렇지 않다. 대부분 소프트웨어의 복잡성은 관리해야 할 **세부사항의 수**에서 온다.
>
> 현세대 설계 도구에 대한 비판과도 이어진다. 세부사항 관리, 특히 오류 처리에 도움이 안 된다. 논리적으로 올바른 경로를 모델링하는 데는 효과적이다. 하지만 이런 경로는 모델링이 필요 없을 만큼 간단한 경우가 많다.
>
> 더 넓게 보면, 소프트웨어 engineering 방법론에 대한 비판과도 맞닿는다. agile을 포함한 현세대 방법론은 주로 새 소프트웨어 개발을 다루고, 유지보수는 특수한 경우로 취급한다. 내 경험이 맞다면, **유지보수가 일반적인 경우**다. waterfall에서 RUP, agile까지, 기존 애플리케이션을 개선하는 전형적 작업에 효과적인 방법론은 거의 없다. 처음부터 설계할 수 있는 위치에 있는 경우는 드물다.
>
> 아마 이게 내가 [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming)을 좋아하는 이유일 것이다. 핵심 유지보수 문제를 다루는 유일한 방법론이라고 본다. [DoTheSimplestThingThatCouldPossiblyWork](http://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork), [OnceAndOnlyOnce](http://wiki.c2.com/?OnceAndOnlyOnce), [RefactorMercilessly](http://wiki.c2.com/?RefactorMercilessly), [TestFirstProgramming](http://wiki.c2.com/?TestFirstProgramming) 등.
>
> -- [HowardFear](http://wiki.c2.com/?HowardFear)

---

### JackReeves 본인의 코멘트

> 이 주제가 여전히 흥미로운 토론을 만들고 있으니 원본 글을 웹에 올렸다. 누군가 이걸 보고 있다니 감격이다. 내가 보기에 소프트웨어 산업 전체에는 *심각한* 품질 문제가 있다. [WilliamEdwardsDeming](http://wiki.c2.com/?WilliamEdwardsDeming)이 반복해서 보여주었듯이, 품질을 진정으로 개선하는 유일한 방법은 프로세스를 고치는 것이다. 프로세스를 고치려면 먼저 이해해야 한다. -- [JackReeves](http://wiki.c2.com/?JackReeves)

---

### "Engineering 활동의 최종 목표는 문서"라는 표현에 대하여

> *"모든 engineering 활동의 최종 목표는 문서를 만드는 것이다."*
>
> 보통보다 더 혼란스럽다. 소프트웨어 engineering의 최종 목표는 프로그램을 만드는 거라고 생각했는데. 소프트웨어 engineering이라는 것 자체가 없다는 또 다른 증거인가? -- [RonJeffries](http://wiki.c2.com/?RonJeffries)

> *그의 표현이 혼란스러운 이유가 있다. "documentation"이라는 단어를 서로 다르게 쓰기 때문이다. 다리를 만드는 엔지니어를 생각해보자. 도면을 만들어 시공팀에 넘긴다. 전기 엔지니어는 회로도를 만들어 납땜 기술자에게 넘긴다. 우리는 소스 코드를 만들어 소프트웨어를 제조하는 컴퓨터에 넘긴다. 비유가 꽤 잘 맞는다. 우리는 버튼 하나로 설계에서 제품으로 갈 수 있는 최초의 engineering 분야일 뿐이다. 빌드, 즉 구현이 소프트웨어에서 너무 쉬워서 우리가 간과해버린 것이다. 프로그래밍을 구현이라 불렀다. 모든 코딩 결정이 제품의 능력에 영향을 미치는 설계 결정이라는 걸 잊었다.* -- [MichaelFeathers](http://wiki.c2.com/?MichaelFeathers)

> 다리 설계의 목적은 문서도 아니고 다리도 아니다. 사람과 물건을 강 건너편으로 보내는 것이다. 소프트웨어의 목적도 문서도 프로그램도 아니다. 일을 하려는 사람들을 돕는 것이다. -- [WayneMack](http://wiki.c2.com/?WayneMack)

> *다리 **설계**의 목적은 사물을 강 건너편으로 보내는 게 아니다. 다리 건설자에게 이 다리를 어떻게 짓는지 보여주는 것이다. 강을 건너게 하는 건 다리의 목적이다.*
>
> *소프트웨어도 마찬가지다. 소프트웨어 **설계**의 목적은 소프트웨어 빌더(컴파일러 등)에게 프로그램을 어떻게 빌드하는지 보여주는 것이다. 사람들이 일을 하도록 돕는 건 프로그램의 목적이다.* -- [DougKing](http://wiki.c2.com/?DougKing)

> 설계와 사용을 어떻게 분리하나? 사물을 강 건너편으로 보내는 게 목적이 아니라면, "다리"를 어떻게 설계하나? 차량 무게, 차량 수, 강 폭 등을 사용의 맥락 없이 어떻게 아나? 설계가 "다리"가 아닌 "커피 테이블"을 만드는 건지 어떻게 아나? 설계는 사용에 종속된다. -- [WayneMack](http://wiki.c2.com/?WayneMack)

> [WayneMack](http://wiki.c2.com/?WayneMack)에 동의한다. [RalphJohnson](http://wiki.c2.com/?RalphJohnson)의 말로 돌아가겠다. 최종 목적이 사용자가 일을 하도록 돕는 것이고, 코드가 프로그래머의 의도를 항상 100% 반영하지 않으니, 프로그래머와 고객 모두 동의하는 설계 문서가 필수다. 개발자들이 사라진 뒤 문서 대신 텀블위드만 남은 코드를 유지보수해 온 사람으로서 말하겠다. 고용주는 공짜로 바꿔주길 원하지 않고, 고객은 "의도한 대로 안 된다!"고 말한다. 중간에서 누가 맞는지 증명할 방법이 없다. 이상적으로는 모든 use case나 story와, 양쪽이 합의한 fitnesse test suite가 있어야 한다. -- [MattMoran](http://wiki.c2.com/?MattMoran)

---

### 설계에서 제품까지의 스펙트럼

설계와 제품을 양극단으로만 보는 시각에 반론이 있다. 설계와 제품 사이에는 연속체가 있다. "product"에 엄격하게 굴면, runtime의 0과 1이 진정한 최종 제품이다. dynamic library를 고려하면 컴파일러만으로는 이 조건을 충족 못 한다. 단일 제품만 있다는 생각에는 결함이 있다. 중간 제품도 있고, 중간 설계도 있다.

> *소프트웨어 개발에서 코더를 제조자에 비유하며 나사를 예로 드는 건 적절하지 않다. 소프트웨어 개발에서의 나사는 코더가 쓰는 키보드나 모니터에 가깝다. 또한 대부분의 소프트웨어 개발자는 다리 설계에 필요한 세부사항의 양을 잘 모른다. 특히 정적 계산의 수학적 모델이 그렇다. 이 수준의 세부사항은 소스 코드와 충분히 비교할 수 있다. 그러니 고전적인 engineering에서도 Big Design First Only 모델은 없다. 모든 engineering 설계는 대략적인 개요와 매우 상세한 저수준 설계 양쪽으로 구성된다.* -- [BernhardPollak](http://wiki.c2.com/?BernhardPollak)

---

### WaterFall 모델의 기원

> *"소프트웨어 개발의 원래 단계들이 정해졌을 때, 그것들은 완전히 틀렸다."*
>
> Software Engineering 교과서에 따르면, "[WaterFall](http://wiki.c2.com/?WaterFall)"이라는 용어와 단계의 개념은 [ProfessorBoehm](http://wiki.c2.com/?ProfessorBoehm)이 도입했다. 전통적 engineering 관행과 소프트웨어 "저작"을 비교하다가 이 아이디어를 만들었다. 6개월도 안 되어 그는 글의 의도가 생명주기 개념을 소개하는 것이었지 특정 모델이 아니었다며 철회했다. 이미 늦었다.
>
> [WaterFall](http://wiki.c2.com/?WaterFall) 모델에 결함이 있고 유지하기 어렵다. 하지만 유명해진 이유가 있다. 아무 모델도 없는 것보다 어떤 모델이든 낫기 때문이다. 처음 들은 거니 먼저 시도한 것이다. 아이러니하게도, 원래 소프트웨어에 쓰려고 만든 게 아니었다.

---

### 추가 자원

원본 "What Is Software Design?" 에세이는 developer.* Magazine에서 "Code As Design: Three Essays by Jack W. Reeves"라는 세 편의 에세이 세트로 재출판됐다. 다른 두 편은 "What Is Software Design: 13 Years Later"라는 새 에세이와 미출판 서한이다. 서한은 Reeves가 C++ Journal 편집자에게 보낸 것이다. 편집자는 서한 대신 글로 만들어달라고 요청했고, Reeves가 그렇게 했다. 원래 서한 자체도 에세이로서 충분히 읽을 만하다. 이 아이디어에 관심이 있다면 한번 읽어보라.

세 편의 에세이 소개 페이지: [http://www.developerdotstar.com/mag/articles/reeves_design_main.html](http://www.developerdotstar.com/mag/articles/reeves_design_main.html)

---

## 키워드

software design, source code, Jack Reeves, engineering, code as design, manufacturing, [TheSourceCodeIsTheDesign](http://wiki.c2.com/?TheSourceCodeIsTheDesign), [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming), [WaterFall](http://wiki.c2.com/?WaterFall), [BigDesignUpFront](http://wiki.c2.com/?BigDesignUpFront)

## 관련 문서

- [NoSilverBullet](no-silver-bullet.md) — Brooks의 "Silver Bullet은 없다". 소프트웨어의 본질적 어려움이라는 주제에서 Reeves의 통찰과 공명한다.
- [BigBallOfMud](big-ball-of-mud.md) — Foote & Yoder의 아키텍처 패턴 언어. 설계가 코딩 과정의 일부라는 Reeves의 주장이 실제 시스템에서 어떻게 나타나는지 보여준다.
- [TheSourceCodeIsTheDesign](http://wiki.c2.com/?TheSourceCodeIsTheDesign) — 소스 코드가 설계라는 주장에 대한 확장 토론
- [WhatIsSoftware](http://wiki.c2.com/?WhatIsSoftware) — 더 근본적인 질문: 소프트웨어란 무엇인가?
- [AnalogyBetweenProgrammingAndManufacturing](http://wiki.c2.com/?AnalogyBetweenProgrammingAndManufacturing) — 프로그래밍과 제조 사이의 유추
- [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming) — 이 에세이의 통찰을 경험적으로 검증하는 방법론
- [CategoryDefinition](http://wiki.c2.com/?CategoryDefinition)
