---
source: http://wiki.c2.com/?NoSilverBullet
original_source: "https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf"
original_author: Frederick P. Brooks, Jr.
original_date: "1986"
title: NoSilverBullet
contributors: [GlennVanderburg, JimRussell, MartyHeyman, NatPryce, HenryAndrew, SunirShah, DavidCary, TobyThain]
accessed: 2026-02-08
category: foundations
keywords: [silver bullet, essential complexity, accidental complexity, Fred Brooks, productivity, software engineering]
summary: "Silver Bullet은 없다 — 소프트웨어 engineering의 본질과 부수"
---

# Silver Bullet은 없다 (No Silver Bullet)

Frederick P. Brooks, Jr.가 1986년에 던진 질문은 근본적이다. 소프트웨어가 어려운 이유는 본질적(essential) 복잡성 때문이다. 이걸 단번에 해결할 Silver Bullet은 없다.

---

## Fred Brooks의 원본 에세이 (1986)

> **No Silver Bullet -- Essence and Accident in Software Engineering**
> by Frederick P. Brooks, Jr.
> University of North Carolina at Chapel Hill

### Abstract

소프트웨어를 만드는 작업은 두 가지로 나뉜다. 하나는 본질적(essential) 작업이다. 복잡한 개념 구조를 설계하는 일이다. 다른 하나는 부수적(accidental) 작업이다. 이 개념을 프로그래밍 언어로 옮기고, 하드웨어 제약에 맞추는 일이다.

과거에 생산성이 크게 오른 건 부수적 장벽을 걷어냈기 때문이다. 심각한 하드웨어 제약, 불편한 언어, 부족한 기계 시간 같은 것들이다. 부수적 작업이 전체의 9/10을 넘지 않는 한, 이걸 다 없애도 10배 향상은 나오지 않는다.

이제 본질을 다룰 차례다. 복잡한 개념 구조를 만드는 일 자체를 공략해야 한다. Brooks는 네 가지를 제안한다.

- 대중 시장을 활용하라. 사서 쓸 수 있으면 사라.
- 빠른 프로토타이핑으로 요구사항을 반복 정제하라.
- 소프트웨어를 키워라. 점진적으로 기능을 추가하라.
- 위대한 설계자를 발굴하고 육성하라.

### Introduction

민간전승에서 가장 무서운 괴물은 늑대인간이다. 익숙한 얼굴이 느닷없이 공포로 변한다. 사람들은 늑대인간을 물리칠 Silver Bullet을 찾는다.

소프트웨어 프로젝트도 마찬가지다. 적어도 비기술적 관리자 눈에는 그렇다. 단순해 보이던 것이 일정 지연, 예산 초과, 결함 투성이 괴물이 된다. Silver Bullet을 찾는 절박한 외침이 터져 나온다.

그런데 10년 후를 내다봐도 Silver Bullet은 없다. 기술이든 관리 기법이든, 생산성과 신뢰성과 단순성을 10배 끌어올릴 단일 방법은 없다. 이 장에서는 소프트웨어 문제의 본질과 Silver Bullet 후보들을 살펴본다.

회의론이 비관론은 아니다. 놀라운 돌파구는 안 보인다. 하지만 소프트웨어 본질에 맞는 혁신이 여럿 진행 중이다. 꾸준히 개발하고 전파하면 10배 향상도 가능하다. 왕도는 없지만 길은 있다.

질병 관리의 첫걸음을 떠올려 보자. 악마 이론과 체액 이론을 세균 이론으로 바꾼 것이다. 이 전환이 마법적 치료에 대한 환상을 깨뜨렸다. 진보는 한 걸음씩 이뤄진다. 청결이라는 규율에 끈질기게 힘을 쏟아야 한다. 오늘날 소프트웨어 engineering도 다르지 않다.

### 본질적 어려움 (Essential Difficulties)

Silver Bullet이 안 보이는 것만이 문제가 아니다. 소프트웨어의 본질 자체가 그런 발명을 극히 어렵게 만든다. 전자 engineering이 하드웨어에 해준 것 같은 돌파구는 기대하기 어렵다. 2년마다 2배 향상도 기대할 수 없다.

먼저 짚고 넘어갈 게 있다. 소프트웨어 진보가 느린 게 아니다. 하드웨어 진보가 너무 빠른 것이다. 문명이 시작된 이래 어떤 기술도 30년 만에 가격 대비 성능이 백만 배 좋아진 적은 없다.

Aristotle을 따라 어려움을 둘로 나눠보자. **본질(essence)**은 소프트웨어의 본성에 깔린 어려움이다. **부수(accident)**는 현재 생산 방식에 따라오지만 본성 자체는 아닌 어려움이다.

소프트웨어 개체의 본질은 개념들의 구성체다. 데이터 집합, 항목 간 관계, 알고리즘, 함수 호출 같은 것들이다. 이 본질은 추상적이다. 어떤 표현을 쓰든 달라지지 않는다. 그러면서도 매우 정밀하고 상세하다.

소프트웨어에서 진짜 어려운 건 개념 구조를 명세하고, 설계하고, 테스트하는 일이다. 코드로 옮기고 정확성을 검증하는 노동이 아니다. 구문 오류야 여전히 생기겠지만, 개념적 오류에 비하면 잡음에 불과하다.

이게 사실이라면 소프트웨어는 항상 어렵다. 본질적으로 Silver Bullet은 없다.

이 환원 불가능한 본질에는 네 가지 속성이 있다. **복잡성(complexity)**, **순응성(conformity)**, **변경 가능성(changeability)**, **비가시성(invisibility)**.

#### Complexity (복잡성)

소프트웨어는 크기 대비 아마 가장 복잡한 인간 산물이다. 어떤 두 부분도 같지 않다. 같으면 서브루틴으로 합쳐 버리니까. 반복 요소로 가득한 컴퓨터나 건물, 자동차와는 근본적으로 다르다.

디지털 컴퓨터 자체도 대부분의 인간 산물보다 복잡하다. 상태 수가 아주 많다. 소프트웨어 시스템의 상태 수는 거기서 몇 자릿수 더 많다.

규모를 키울 때도 단순 반복이 아니다. 서로 다른 요소의 수가 늘어난다. 요소들은 비선형적으로 상호작용한다. 전체 복잡성은 선형보다 훨씬 빠르게 치솟는다.

이 복잡성은 본질적 속성이다. 추상화로 걷어내면 본질도 함께 사라진다. 수학과 물리학은 복잡한 현상을 단순 모델로 만들어 왔다. 모델에서 무시한 복잡성이 현상의 본질이 아니었기에 가능했다. 그런데 복잡성 자체가 본질이면? 이 방법은 통하지 않는다.

본질적 복잡성(essential complexity)에서 소프트웨어의 고전적 문제들이 나온다. 복잡하니까 팀원 간 소통이 어렵다. 제품 결함, 비용 초과, 일정 지연이 뒤따른다. 가능한 상태를 열거하기 어려우니 신뢰성이 떨어진다. 기능이 복잡하니 프로그램 쓰기가 힘들다. 구조가 복잡하니 부작용 없이 확장하기 어렵다.

관리 문제도 복잡성 때문이다. 전체를 조망하기 어려우니 개념적 일관성(conceptual integrity)이 무너진다. 미완의 부분을 찾아 수습하기 힘들다. 사람이 바뀌면 학습 부담이 막대하다.

#### Conformity (순응성)

복잡성과 씨름하는 건 소프트웨어만이 아니다. 물리학도 기본 입자 수준에서 극도로 복잡하다. 하지만 물리학자에게는 통합 원리가 있다는 확신이 있다. Einstein은 자연에 단순한 설명이 있어야 한다고 거듭 주장했다.

소프트웨어 엔지니어에게 그런 위안은 없다. 다뤄야 할 복잡성 대부분이 자의적이다. 수많은 인간 제도와 시스템이 별 이유 없이 복잡성을 강제한다. 인터페이스마다, 시대마다 다르다. 저마다 다른 사람이 설계했으니까.

소프트웨어가 순응해야 하는 이유는 간단하다. 가장 나중에 현장에 왔고, 가장 바꾸기 쉽다고 여겨지기 때문이다. 순응에서 오는 복잡성은 소프트웨어만 재설계해서는 없앨 수 없다.

#### Changeability (변경 가능성)

소프트웨어는 끊임없이 변경 압력을 받는다. 건물이나 자동차도 바뀌긴 하지만, 만들어진 뒤에는 드물게 바뀐다. 소프트웨어는 훨씬 자주 바뀐다.

이유가 두 가지다. 첫째, 소프트웨어가 시스템의 기능을 맡고 있다. 기능은 변경 압력이 가장 큰 부분이다. 둘째, 소프트웨어는 바꾸기 쉬워 보인다. 순수한 사고의 산물이니 무한히 유연하다고 느낀다. 건물은 고치려면 돈이 많이 든다는 걸 누구나 안다. 그래서 변덕이 억제된다.

성공한 소프트웨어는 반드시 바뀐다. 두 가지 흐름이 작용한다. 첫째, 유용하다고 알려지면 사람들은 원래 도메인 밖에도 적용하려 한다. 둘째, 성공한 소프트웨어는 원래 기계보다 오래 살아남는다. 새 컴퓨터, 새 디스크, 새 디스플레이에 맞춰야 한다.

결국 소프트웨어는 응용, 사용자, 법률, 기계라는 문화 환경 속에 놓여 있다. 이 환경은 끊임없이 변한다. 그 변화가 소프트웨어 변경을 피할 수 없게 만든다.

#### Invisibility (비가시성)

소프트웨어는 눈에 보이지 않고, 시각화하기도 어렵다. 기하학적 추상화는 강력한 도구다. 건물 평면도는 건축가와 고객 모두에게 공간과 동선을 보여준다. 모순이 드러나고 빠진 것이 발견된다.

소프트웨어는 본질적으로 공간 위에 있지 않다. 토지에 지도가, 칩에 다이어그램이 있듯 기성의 기하학적 표현이 없다. 구조를 그려 보면 하나의 그래프가 아니다. 제어 흐름, 데이터 흐름, 의존 관계, 시간 순서, 이름 공간이 각각 별도의 유향 그래프를 이룬다. 평면적이지도 계층적이지도 않다.

소프트웨어 구조를 단순하게 만들려는 노력에도 불구하고, 시각화는 본질적으로 어렵다. 가장 강력한 개념적 도구를 쓸 수 없게 된다. 개인의 설계를 방해할 뿐 아니라, 사람 사이의 소통도 심각하게 막는다.

### 과거의 돌파구 (Past Breakthroughs)

과거 소프트웨어 기술에서 가장 큰 성과를 낸 세 단계를 보자. 각각 주요 어려움을 공격했다. 다만 본질적이 아닌 부수적 어려움이었다.

#### High-level languages (고수준 언어)

생산성, 신뢰성, 단순성을 위한 가장 강력한 한 수는 고수준 언어였다. 대부분의 관찰자는 개발 생산성이 최소 5배 올랐다고 본다. 신뢰성과 이해도도 함께 좋아졌다.

고수준 언어가 뭘 해준 걸까? 프로그램을 부수적 복잡성(accidental complexity)에서 해방했다. 추상적 프로그램은 연산, 데이터 타입, 시퀀스, 통신으로 이루어진다. 구체적 기계 프로그램은 비트, 레지스터, 조건, 분기, 채널, 디스크를 다룬다. 고수준 언어가 추상 구성물을 직접 제공하고 하위 수준을 숨겨 준다. 프로그램에 원래 없던 한 층의 복잡성이 통째로 사라진다.

물론 한계도 있다. 최대치는 프로그래머가 상상하는 모든 구성물을 제공하는 것이다. 어느 시점부터는 거의 안 쓰는 구성물까지 쌓여서 오히려 지적 부담이 늘어난다.

#### Time-sharing (시분할)

대부분의 관찰자는 시분할이 생산성을 크게 올렸다고 본다. 고수준 언어만큼은 아니지만.

시분할은 다른 어려움을 공격한다. 즉시성을 지켜서 복잡성의 전체 그림을 유지하게 해준다. 일괄 처리의 느린 반복 주기에서는 컴파일과 실행을 기다려야 한다. 기다리는 동안 세부 사항은 물론 핵심 맥락까지 잊어버린다.

느린 반복 주기는 부수적 어려움이다. 시분할이 해준 건 응답 시간을 줄인 것뿐이다. 인간 인지 임계값인 약 100밀리초 아래로 내려가면 더 이상 이득이 없다.

#### Unified programming environments (통합 프로그래밍 환경)

Unix와 Interlisp가 대표적이다. 생산성을 몇 배로 올린 것으로 평가받는다.

이들은 프로그램을 함께 쓰는 부수적 어려움을 공격했다. 통합 라이브러리, 통일된 파일 형식, 파이프와 필터를 제공한다. 프로그램들이 서로 호출하고 데이터를 주고받을 수 있다. 표준 형식 덕분에 새 도구를 어떤 프로그램에든 붙일 수 있다. 도구 생태계가 폭발적으로 발전했다.

### Silver Bullet 후보 검토 (Hopes for the Silver)

가장 많이 거론되는 Silver Bullet 후보를 살펴보자. 이것들이 다루는 문제는 본질인가, 부수인가? 혁명적 진보인가, 점진적 진보인가?

#### Ada와 고수준 언어의 진보

1980년대 가장 주목받은 것 중 하나가 Ada다. 언어 개념을 진화적으로 개선하면서 현대적 설계와 모듈화를 장려하는 기능을 담았다. Ada 철학이 Ada 언어보다 더 큰 진보일 수 있다. 모듈화, 추상 데이터 타입, 계층적 구조화라는 철학 말이다.

하지만 Ada는 Silver Bullet이 아니다. 결국 또 하나의 고수준 언어다. 가장 큰 보상은 첫 전환에서 왔다. 기계의 부수적 복잡성에서 벗어나 추상적 서술로 옮겨간 것이다. 그 뒤에 남은 부수적 요소는 더 작고, 보상도 더 작다.

Ada의 진짜 공헌은 뭘까? 프로그래머들이 Ada로 전환하면서 현대적 설계 기법을 익히게 된 점이다.

#### Object-oriented programming (객체 지향 프로그래밍)

많은 전문가가 객체 지향 프로그래밍에 큰 기대를 건다. Brooks도 그중 하나다. 두 개념을 구분할 필요가 있다. 추상 데이터 타입과 계층적 타입, 즉 클래스다.

추상 데이터 타입은 이름, 값, 연산으로 객체 타입을 정의한다. 저장 구조는 숨긴다. 계층적 타입은 일반 인터페이스를 정의하고 하위 타입으로 정제한다. 두 개념은 직교한다. 숨김 없는 계층도, 계층 없는 숨김도 가능하다. 둘 다 진짜 발전이다.

하지만 설계 표현의 부수적 어려움을 모두 없앨 수는 있어도, 그 이상은 할 수 없다. 설계 자체의 복잡성은 본질적이다. 불필요한 타입 명세가 전체 작업의 9/10을 차지하지 않는 한, 10배 향상은 불가능하다.

#### Artificial intelligence (인공지능)

많은 사람이 인공지능에서 10배 향상을 기대한다. Brooks는 동의하지 않는다. AI 정의가 두 가지 있다.

- **AI-1**: 인간 지능이 필요했던 문제를 컴퓨터로 푸는 것
- **AI-2**: 규칙 기반 프로그래밍이라는 특정 기법

Parnas는 AI-1의 정의가 계속 바뀐다고 지적한다. 프로그램이 어떻게 돌아가는지 알게 되면 더 이상 AI라 부르지 않는다. AI-2는 특정 문제에 묶여서 다른 곳에 옮기기 어렵다. 소프트웨어에서 어려운 건 무엇을 말할지 결정하는 것이지, 말하는 행위가 아니다. 표현을 쉽게 해줘도 주변적 이득에 그친다.

#### Expert systems (전문가 시스템)

AI 기술 중 가장 발전하고 널리 쓰이는 건 전문가 시스템이다. 일반화된 추론 엔진과 규칙 기반을 갖춘 프로그램이다. 입력 데이터와 가정을 받아 결론을 내놓고, 추론 과정을 설명해 준다.

가장 큰 공헌은 미숙한 프로그래머에게 최고 프로그래머의 지혜를 전하는 것이다. 최고와 평균의 격차는 매우 크다. 아마 다른 어떤 engineering 분야보다 클 것이다. 좋은 실무를 퍼뜨리는 도구는 중요하다.

#### "Automatic" programming (자동 프로그래밍)

40년간 사람들은 문제 명세에서 프로그램이 자동으로 나오길 기대했다. Parnas는 이 용어가 실질보다 매력 때문에 쓰인다고 지적한다. "자동 프로그래밍"이란 더 높은 수준의 언어로 프로그래밍하는 것을 그럴듯하게 부른 말에 불과하다.

자동 생성이 되는 영역이 있긴 하다. 정렬이나 미분방정식 풀이 같은 것이다. 문제를 적은 파라미터로 표현할 수 있고, 알려진 해법이 많고, 파라미터에 따라 기법을 고르는 규칙이 있다. 하지만 이런 깔끔한 조건은 예외다. 일반 소프트웨어로 확장하기 어렵다.

#### Graphical programming (그래픽 프로그래밍)

소프트웨어 설계에 컴퓨터 그래픽을 적용하자는 건 단골 연구 주제다. 아직 설득력 있는 결과는 없다.

첫째, 흐름도는 소프트웨어 구조를 아주 빈약하게 보여준다. 프로그래머는 프로그램을 다 쓴 뒤에 흐름도를 그리지, 그 전에 그리지 않는다.

둘째, 화면이 너무 작다. 제대로 된 소프트웨어 다이어그램의 범위와 해상도를 동시에 보여줄 수 없다. 워크스테이션의 "데스크톱 메타포"는 사실 "비행기 좌석" 메타포에 더 가깝다. 진짜 책상은 수십 페이지를 펼쳐 놓고 한눈에 볼 수 있다.

더 근본적으로, 소프트웨어는 시각화하기가 매우 어렵다. 뭘 그리든 복잡하게 엮인 소프트웨어의 한 차원만 볼 뿐이다. VLSI 칩과의 비유는 잘못된 길로 이끈다. 칩은 기하학이 본질인 2차원 객체지만, 소프트웨어는 그렇지 않다.

#### Program verification (프로그램 검증)

프로그램 검증은 강력한 개념이다. 보안 커널 같은 곳에서 특히 중요하다. 하지만 노동을 줄여주겠다고 약속하지는 않는다. 검증에 드는 작업량이 막대해서 소수의 프로그램만 검증되었다.

검증이 오류 없는 프로그램을 뜻하지도 않는다. 수학적 증명에도 오류가 있다. 테스트 부담을 줄일 수는 있지만 없앨 수는 없다.

더 심각한 문제가 있다. 완벽하게 검증해도 프로그램이 명세에 맞는다는 것만 확인해 줄 뿐이다. 진짜 어려운 건 완전하고 일관된 명세에 도달하는 것이다. 소프트웨어 본질의 상당 부분이 명세를 디버깅하는 일이다.

#### Environments and tools (환경과 도구)

큰 보상을 주는 문제들은 이미 풀렸다. 계층적 파일 시스템, 통일된 파일 형식, 범용 도구 같은 것들이다.

아직 안 풀린 가장 큰 과제는 통합 데이터베이스 시스템이다. 수많은 세부사항을 추적하고 협업자 간 최신 상태를 유지하는 시스템이다. 가치 있는 작업이지만, 앞으로 거둘 수확은 제한적이다.

#### Workstations (워크스테이션)

프로그램 작성과 편집은 이미 충분히 빠르다. 기계 속도가 10배가 되면 사고 시간만 남을 것이다. 사실 이미 그런 것 같다. 더 강력한 워크스테이션은 반가운 일이지만, 마법 같은 향상은 기대할 수 없다.

### 본질에 대한 유망한 공격 (Promising Attacks on the Conceptual Essence)

기술적 돌파구가 하드웨어 같은 마법적 결과를 줄 수는 없다. 하지만 좋은 작업은 풍부하다. 꾸준하지만 눈에 잘 안 띄는 진보가 기대된다.

부수적 요소를 공격하는 건 생산성 방정식의 한계에 갇힌다. 개념 작업이 시간 대부분을 잡아먹는다면, 표현 작업을 아무리 개선해도 큰 향상은 없다. 그러니 본질을 공략해야 한다.

#### Buy versus build (사서 쓰기 vs. 직접 만들기)

가장 급진적인 해법은 아예 만들지 않는 것이다.

그리고 날마다 더 쉬워지고 있다. 소프트웨어 비용은 항상 개발 비용이지 복제 비용이 아니다. 사용자가 늘수록 1인당 비용은 급격히 줄어든다. n개 복사본을 쓰는 건 개발자 생산성을 n배로 곱하는 셈이다.

핵심은 적용 가능성이다. 1960년에 200만 달러짜리 기계를 산 사람은 달랐다. 맞춤형 급여 프로그램에 25만 달러를 더 쓸 수 있다고 느꼈다. 하지만 5만 달러 사무기기를 산 사람은 맞춤형을 감당할 수 없다. 패키지에 자기 절차를 맞춘다. 변한 건 패키지가 아니라 비용 비율이다.

가장 극적인 예는 전자 스프레드시트와 단순 데이터베이스다. 돌이켜 보면 너무 뻔한데, 너무 늦게 나왔다. 수많은 용도에 쓰이고 있다.

Brooks는 대규모 조직의 가장 강력한 생산성 전략이 이것이라고 본다. 현장의 지적 노동자에게 개인 컴퓨터와 좋은 범용 소프트웨어를 주고 자유롭게 쓰게 하는 것이다.

#### Requirements refinement and rapid prototyping (요구사항 정제와 빠른 프로토타이핑)

소프트웨어를 만들 때 가장 어려운 건 무엇을 만들지 결정하는 것이다. 상세 요구사항을 세우는 것만큼 어려운 개념 작업은 없다. 여기서 잘못되면 치명적이다. 나중에 고치기도 가장 어렵다.

그래서 가장 중요한 일은 요구사항을 반복적으로 뽑아내고 다듬는 것이다. 고객은 자기가 뭘 원하는지 모른다. 어떤 질문에 답해야 하는지도 모른다. 문제의 세부사항을 깊이 생각해 본 적도 드물다.

가장 유망한 기술적 노력 중 하나가 빠른 프로토타이핑이다. 부수가 아닌 본질을 공격한다. 시스템을 빠르게 시제품으로 만들어서 고객이 직접 일관성과 사용성을 테스트하게 한다. 반복적 정제의 핵심 도구다.

현재의 많은 조달 절차는 시스템을 미리 완전히 명세할 수 있다는 가정 위에 서 있다. 이 가정은 근본적으로 틀렸다. Brooks는 한 발 더 나간다. 실제로 만들어 써보기 전에는 정확한 요구사항을 완전히 명세할 수 없다고 주장한다.

#### Incremental development -- grow, not build (점진적 개발 -- 만들지 말고 키워라)

건축 은유는 쓸모를 다했다. 우리가 만드는 개념 구조는 미리 정확히 명세하기엔 너무 복잡하다. 결함 없이 만들기에도 너무 복잡하다. 근본적으로 다른 접근이 필요하다.

자연에서 힌트를 얻자. 뇌 하나만 봐도 인간의 어떤 산물보다 복잡하고 강력하다. 비밀은 만들어진 게 아니라 자라났다는 데 있다.

Harlan Mills는 모든 소프트웨어를 점진적으로 키워야 한다고 제안했다. 먼저 실행 가능하게 만든다. 빈 서브프로그램만 호출하더라도 좋다. 그런 다음 한 비트씩 살을 붙인다.

사기에 주는 효과가 놀랍다. 단순하더라도 돌아가는 시스템이 있으면 열정이 솟는다. 새 그래픽 시스템에서 첫 그림이 뜰 때, 직사각형 하나뿐이더라도 힘이 배가된다. 매 단계마다 작동하는 시스템이 있다. 팀은 4개월 만에 만들 수 있는 것보다 훨씬 복잡한 것을 키워낼 수 있다.

#### Great designers (위대한 설계자)

소프트웨어 기술을 어떻게 올릴 것인가? 결국 사람의 문제다.

좋은 설계 실천을 따르면 좋은 설계가 나온다. 좋은 실천은 가르칠 수 있다. 하지만 좋은 설계와 위대한 설계의 차이는 방법론에 있지 않다. **위대한 설계는 위대한 설계자에게서 나온다.** 건전한 방법론은 창조적 마음에 힘을 주지만, 불을 지피지는 못한다.

그 차이는 사소하지 않다. Salieri와 Mozart의 차이다. 최고의 설계자들은 더 빠르고, 더 작고, 더 깔끔하게, 더 적은 노력으로 구조를 만든다. 위대한 설계자와 평균의 차이는 10배에 달한다.

열정적 팬을 가진 소프트웨어를 보자. Unix, APL, Pascal, Modula, Smalltalk 인터페이스, 심지어 Fortran. 모두 한두 명의 설계 정신이 만든 것이다.

Brooks는 가장 중요한 일이 위대한 설계자를 키우는 것이라고 본다. 대부분의 조직은 관리자 후보를 찾고 키우는 데 힘을 쏟는다. 위대한 설계자에게 같은 수준의 노력을 기울이는 조직은 없다.

첫 번째 제안은 이것이다. 위대한 설계자가 위대한 관리자만큼 중요하다고 선언하라. 비슷하게 키우고 보상하라. 급여뿐 아니라 인정과 대우도 동등해야 한다.

위대한 설계자를 키우는 방법은 다음과 같다.

- 가능한 한 빨리 최고 설계자를 체계적으로 찾아라. 최고가 반드시 가장 경험 많은 사람은 아니다.
- 후보에게 경력 멘토를 붙여라.
- 최고 설계자와의 도제 과정, 정규 교육, 단기 과정을 포함한 경력 개발 계획을 세워라.
- 성장하는 설계자들이 서로 만나고 자극할 기회를 만들어라.

---

## wiki.c2.com 토론

### 논문 해설 (GlennVanderburg)

[GlennVanderburg](http://wiki.c2.com/?GlennVanderburg)가 이 논문의 핵심을 정리한다.

이 논문은 세 번 출판됐다. IFIP '86 학회, IEEE Computer 1987년 4월호, [MythicalManMonth](http://wiki.c2.com/?MythicalManMonth) 20주년 기념판이다. Brooks가 "silver bullet"이라는 말을 소프트웨어 분야에 가져왔다.

이 용어가 흔히 느슨하게 쓰이지만, Brooks는 정확히 정의했다.

> *"기술이든 관리 기법이든, 그 자체로 소프트웨어의 생산성, 신뢰성, 단순성에서 10배 향상을 약속하는 단일 방법"*

논문의 핵심 주장은 이렇다. 1986년 현재 그런 Silver Bullet은 안 보인다. 최소 10년간 나타나지 않을 것이다.

Brooks 논증의 핵심은 essence와 accident의 구분이다. Essence는 문제와 해법의 추상적 개념 구조에 깔린 복잡성이다. Accident은 소프트웨어를 실제로 만드는 방식이 떠안기는 부수적 복잡성이다. 물리적 제한, 언어의 낮은 추상화 수준, 불완전한 요구사항 명세, 비효율적 소통 같은 것들이다. Brooks는 본질적 이슈가 전체의 1/10을 훨씬 넘는다고 주장한다. 당시의 혁신들은 부수적 이슈를 공격하고 있었다. 그러니 어떤 것도 10배 향상의 이론적 가능성조차 없었다.

20주년 기념판에는 "No Silver Bullet" Refired 에세이가 실렸다. 원본을 9년 뒤에 다시 들여다본 글이다. Brooks는 "accidental"이라는 단어 선택이 혼란을 줬다고 다루며, "incidental"이 더 나았을 수 있다고 인정한다.

### 과거의 Silver Bullet들 (Past Silver Bullets)

[DavidCary](http://wiki.c2.com/?DavidCary)와 [SunirShah](http://wiki.c2.com/?SunirShah)가 과거 Silver Bullet 수준의 향상을 가져온 기술들을 정리했다.

- stored-program 개념
- 어셈블러 (1949, UNIVAC 1용 Short Code)
- 서브루틴과 리턴 스택
- 최초의 컴파일러 (1952, [GraceHopper](http://wiki.c2.com/?GraceHopper))
- 최초의 고수준 언어 ([FortranLanguage](http://wiki.c2.com/?FortranLanguage), 1954)
- 마우스 (1964, Douglas Engelbart)
- 실시간 디스플레이 에디터
- [GraphicalUserInterface](http://wiki.c2.com/?GraphicalUserInterface)
- [IntegratedDevelopmentEnvironment](http://wiki.c2.com/?IntegratedDevelopmentEnvironment)
- 대량 생산 개인용 컴퓨터
- [RelationalDatabase](http://wiki.c2.com/?RelationalDatabase)
- World Wide Web
- [ObjectOrientedProgramming](http://wiki.c2.com/?ObjectOrientedProgramming)
- [DesignPatterns](http://wiki.c2.com/?DesignPatterns)
- [ExtremeProgramming](http://wiki.c2.com/?ExtremeProgramming) ([XpIsNotaSilverBullet](http://wiki.c2.com/?XpIsNotaSilverBullet))

[TobyThain](http://wiki.c2.com/?TobyThain)은 이 목록에 문제를 제기했다. **진짜** Silver Bullet(예: 컴파일러)과 **과대포장된** Silver Bullet(예: [DotNet](http://wiki.c2.com/?DotNet))이 섞여 있다는 것이다.

Brooks의 요점은 이렇다. 과거 Silver Bullet들은 모두 프로그래밍의 부수적 성가심을 공격했다. 남아 있는 부수적 성가심이 전체의 9/10이 안 되니, 단 한 번의 10배 향상도 나올 수 없다.

### 실무 관점

#### HenryAndrew의 프로젝트 사례

[HenryAndrew](http://wiki.c2.com/?HenryAndrew)가 실무 경험으로 Brooks의 주장을 뒷받침한다.

그가 참여한 프로젝트에는 개발자 2명이 있었다. 요구사항 수집, 분석, 테스트도 겸했다. 프로젝트 관리자 2명, 전임 테스터 1명, 전임 비즈니스 분석가 1명도 있었다. 관리 업무만 해도 최소 3명이 더 필요했다. 비용을 줄이려고 개발자 2명을 해외 개발자 3명으로 바꿨다. 그 시점부터 완료일이 300% 밀렸다.

핵심 통찰은 이렇다. **프로그래밍은 시스템 전달 비용 빙산의 꼭대기일 뿐이다.** 비프로그래머 7명의 PC 유지보수 비용도 프로젝트 비용이다. 프로그래머가 회의에 나가고 진행 상황을 보고하는 시간도 마찬가지다. 시스템 전달에서 줄일 곳은 많다. 하지만 프로그래밍은 좋은 출발점이 아니다.

#### NatPryce의 리팩토링 도구 관점

[NatPryce](http://wiki.c2.com/?NatPryce)는 자동 리팩토링 도구에서 엄청난 생산성 향상을 경험했다. [JavaLanguage](http://wiki.c2.com/?JavaLanguage)와 [EclipseIde](http://wiki.c2.com/?EclipseIde)의 자동 리팩토링 덕분이다. 이해가 깊어지면서 코드가 그 이해를 반영하는 방식을 쉽게 바꿀 수 있다. 그래서 리팩토링 도구가 프로그래밍의 본질적 문제를 공격한다고 주장한다. 이른바 더 생산적인 언어([RubyLanguage](http://wiki.c2.com/?RubyLanguage), [PythonLanguage](http://wiki.c2.com/?PythonLanguage) 등)에서 오히려 작업이 어려워진 이유도 같은 맥락이다. 리팩토링이 훨씬 느려지기 때문이라고 말한다.

#### JimRussell의 관점

[JimRussell](http://wiki.c2.com/?JimRussell)은 Brooks가 10배라는 높은 기준을 세운 배경을 짚어준다. 당시 하드웨어 세계에서는 Moore's Law가 군림했고, 소프트웨어 향상은 느렸다. 이 불균형이 많이 이야기되던 때였다.

대부분의 사람은 개발 생산성 2배면 행복하다. 10% 향상이면 상사가 복도에서 춤출 것이다. APL처럼 10배 향상이 가능한 도구가 있다 치자. 도구가 널리 쓰일지는 다른 요인이 좌우한다.

#### MartyHeyman의 관점

[MartyHeyman](http://wiki.c2.com/?MartyHeyman)은 개발자에게 Silver Bullet이 있었다면 끊임없이 늘어나는 컴퓨터 파워뿐이라고 본다. 도구는 좋아졌다. 재사용 가능한 코드도 상당히 쌓였다. 하지만 뚜렷한 Silver Bullet은 없다.

### 관련 링크

- [NoSilverBulletRevisited](http://wiki.c2.com/?NoSilverBulletRevisited) -- Brooks의 후속 에세이 토론
- [XpIsNotaSilverBullet](http://wiki.c2.com/?XpIsNotaSilverBullet) -- Extreme Programming과 Silver Bullet
- [NoNoSilverBulletBullet](http://wiki.c2.com/?NoNoSilverBulletBullet) -- "No Silver Bullet은 없다"는 반론
- [GoldenHammer](http://wiki.c2.com/?GoldenHammer) -- 만능 도구 anti-pattern
- [FredBrooks](http://wiki.c2.com/?FredBrooks) -- 저자 페이지
- [MythicalManMonth](http://wiki.c2.com/?MythicalManMonth) -- Brooks의 대표 저서

---

## 키워드

- **Silver Bullet**: 소프트웨어 생산성을 10배 높일 단일 기술이나 관리 기법. Brooks는 그런 건 없다고 주장한다.
- **Essential Complexity**: 문제와 해법에 깔린 복잡성. 제거할 수 없다.
- **Accidental Complexity**: 현재 생산 방식이 떠안기는 부수적 복잡성. 도구와 기법으로 줄일 수 있다.
- **Conceptual Integrity**: 시스템 설계의 일관성. Brooks가 가장 중시하는 가치.
- **Rapid Prototyping**: 요구사항을 반복적으로 다듬기 위해 빠르게 시제품을 만드는 접근.
- **Incremental Development**: 소프트웨어를 한 번에 만들지 않고 점진적으로 키우는 접근.

## 관련 문서

- [WhatIsSoftwareDesign](what-is-software-design.md) -- Jack Reeves의 "소스 코드가 곧 설계" 논문. Brooks의 본질적 어려움과 맞닿아 있다.
- [BigBallOfMud](big-ball-of-mud.md) -- Foote & Yoder의 소프트웨어 아키텍처론. 본질적 복잡성이 실제 시스템에서 어떻게 드러나는지 보여준다.
