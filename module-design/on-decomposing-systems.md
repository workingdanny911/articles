---
source: http://wiki.c2.com/?OnDecomposingSystems
original_source: "https://wstomv.win.tue.nl/edu/2ip30/references/criteria_for_modularization.pdf"
original_author: David Parnas
original_date: "1972"
title: OnDecomposingSystems
contributors: [RalphJohnson, MarcGrundfest, TopMind]
accessed: 2026-02-09
category: module-design
keywords: [information hiding, modularization, decomposition, KWIC, changeability, module, design decision, hierarchical structure]
summary: "모듈 분해의 기준은 처리 단계가 아니라 변경 가능성이다 — Parnas 1972 논문과 wiki 토론"
---

# 시스템을 모듈로 분해하는 기준에 대하여

David Parnas는 1972년 Communications of the ACM에 이 논문을 발표했다. 모듈러 프로그래밍이 유행하던 시대, 아무도 묻지 않던 질문을 던졌다. "모듈을 어떤 기준으로 나눠야 하는가?" KWIC 인덱스라는 예제로 두 가지 분해를 비교했다. 처리 단계가 아닌 "변경될 가능성이 높은 설계 결정"을 기준으로 삼아야 한다고 주장했다. 정보 은닉(information hiding) 개념의 원천이 된 기초 문헌이다.

---

## 서론

모듈러 프로그래밍의 철학을 명쾌하게 서술한 글이 있다. Gauthier와 Pont가 1970년에 쓴 시스템 프로그램 설계 교과서 [1, ¶10.23]다. 아래에 인용한다.

> 프로젝트 작업을 잘 정의된 단위로 나누면 시스템의 모듈성이 보장된다. 각 작업은 별도의 독립된 프로그램 모듈이 된다. 구현 시점에 각 모듈의 입출력이 명확히 정의되어 있으므로, 다른 모듈과의 인터페이스에 혼란이 없다. 검증 시점에 모듈의 무결성을 독립적으로 테스트할 수 있다. 여러 작업의 완료 시점을 맞추느라 일정이 꼬이는 일도 거의 없다. 마지막으로, 시스템을 모듈 단위로 유지보수할 수 있다. 오류와 결함을 특정 모듈까지 추적할 수 있어, 상세 오류 탐색의 범위가 줄어든다.

보통 시스템을 모듈로 나눌 때 **어떤 기준**을 써야 하는지에 대해서는 아무 말이 없다. 이 논문에서는 바로 그 문제를 다루려 한다. 예제를 통해 시스템 분해에 쓸 수 있는 기준 몇 가지를 제안한다.

## 현황 보고

모듈러 프로그래밍 분야에서 가장 큰 진전은 코딩 기법과 어셈블러의 발전이다. 이 기법 덕분에 두 가지가 가능해졌다. (1) 다른 모듈의 코드를 거의 몰라도 하나의 모듈을 작성할 수 있다. (2) 전체 시스템을 다시 조립하지 않아도 모듈을 교체할 수 있다.

이 기능은 대규모 코드를 생산할 때 매우 유용하다. 그러나 문제 시스템의 사례로 자주 거론되는 시스템들도 이미 고도로 모듈화되어 있고, 위에서 언급한 기법들을 사용하고 있다.

## 모듈러 프로그래밍에 기대하는 효과

모듈러 프로그래밍에 기대하는 효과는 다음 세 가지다.

1. **관리 측면** — 개발 기간을 단축할 수 있다. 각 모듈을 별도 그룹이 맡아 작업하면 그룹 간 소통을 최소화할 수 있기 때문이다.
2. **유연성** — 한 모듈을 크게 바꿔도 다른 모듈은 바꿀 필요가 없어야 한다.
3. **이해 용이성** — 시스템을 한 번에 모듈 하나씩 살펴볼 수 있어야 한다. 각 부분을 잘 이해할 수 있으면, 전체 시스템도 더 잘 설계할 수 있다.

## 모듈화란 무엇인가?

아래에 여러 가지 시스템 기술 방식을 제시한다. 이를 모듈화라고 부른다. 여기서 "모듈"은 서브프로그램이 아니라 **책임 배분**을 뜻한다. 각 모듈화에는 독립 모듈 작업을 시작하기 전에 반드시 내려야 할 설계 결정들이 포함된다.

대안마다 포함하는 결정이 상당히 다르다. 다만 모든 경우에 "시스템 수준"의 결정, 즉 하나 이상의 모듈에 영향을 미치는 결정을 모두 기술하려는 의도는 같다.

## 예제 시스템: KWIC 인덱스 생성 시스템

KWIC(Key Word In Context) 인덱스 시스템을 설명한다. 이 시스템은 순서가 있는 행(line)의 집합을 입력받는다. 각 행은 단어의 순서열이고, 각 단어는 문자의 순서열이다. 어떤 행이든 첫 번째 단어를 떼어 맨 끝에 붙이는 작업을 반복할 수 있다. 이것을 "순환 시프트(circular shift)"라 한다. KWIC 인덱스 시스템은 모든 행의 모든 순환 시프트를 알파벳 순으로 출력한다.

이 시스템은 작다. 극단적인 상황(거대한 데이터베이스, 지원 소프트웨어 부재)이 아니라면, 실력 있는 프로그래머가 1~2주면 만들 수 있다. 따라서 모듈러 프로그래밍의 동기가 되는 어려움은 이 시스템에서 중요하지 않다. 하지만 큰 시스템을 깊이 다루기란 현실적으로 어렵다. 그러니 이 작은 문제를 큰 프로젝트처럼 다루는 연습을 해 보자.

현재 일반적으로 쓰이는 방식의 모듈화 하나와, 학부 수업 프로젝트에서 성공적으로 사용한 다른 방식의 모듈화 하나를 제시한다.

## 모듈화 1

다음과 같은 모듈로 나눈다.

**모듈 1: 입력.** 이 모듈은 입력 매체에서 데이터 행을 읽어 메모리에 저장한다. 나머지 모듈이 처리할 수 있게 하기 위해서다. 문자는 한 워드에 네 개씩 묶어 저장한다. 단어의 끝은 사용하지 않는 특수 문자로 표시한다. 각 행의 시작 주소를 가리키는 인덱스를 유지한다.

**모듈 2: 순환 시프트.** 이 모듈은 입력 모듈의 작업이 끝난 뒤에 호출된다. 각 순환 시프트의 첫 문자 주소와 원래 행의 인덱스를 담은 인덱스를 만든다. 출력은 메모리에 남긴다. 쌍(원래 행 번호, 시작 주소) 형식으로 저장한다.

**모듈 3: 정렬.** 이 모듈은 모듈 1과 모듈 2가 만든 배열을 입력으로 받는다. 모듈 2와 같은 형식의 배열을 만든다. 다만 이번에는 순환 시프트가 알파벳 순으로 나열된다.

**모듈 4: 출력.** 모듈 3과 모듈 1이 만든 배열을 사용하여, 모든 순환 시프트를 보기 좋게 정리한 목록을 출력한다. 정교한 시스템이라면 각 행의 실제 시작점을 표시할 수 있다. 추가 정보를 가리키는 포인터를 넣을 수도 있다. 순환 시프트의 시작이 행의 첫 단어가 아닐 수도 있다.

**모듈 5: 마스터 컨트롤.** 이 모듈은 나머지 네 모듈의 실행 순서를 제어하는 정도의 역할만 한다. 오류 메시지 처리나 공간 할당 같은 일도 할 수 있다.

위 내용이 최종 문서가 아니라는 점은 분명하다. 작업을 시작하려면 훨씬 더 많은 정보를 제공해야 한다. 정의 문서에는 메모리 형식, 포인터 규약, 호출 규약 등을 보여주는 그림이 여럿 포함될 것이다. 네 모듈 사이의 모든 인터페이스를 작업 시작 전에 명세해야 한다.

모듈러 프로그래밍 지지자들이 말하는 의미 그대로의 모듈화다. 시스템이 잘 정의된 인터페이스를 가진 여러 모듈로 나뉘어 있다. 각 모듈은 충분히 작고 단순해서 완전히 이해하고 잘 프로그래밍할 수 있다. 소규모 실험에 따르면, 대부분의 프로그래머가 이 과제에 대해 대략 이런 식의 분해를 제안할 것이다.

## 모듈화 2

다음과 같은 모듈로 나눈다.

**모듈 1: 행 저장소(Line Storage).** 이 모듈은 여러 함수 또는 서브루틴으로 구성된다. 이 모듈을 사용하는 쪽은 이 함수들을 통해 모듈에 접근한다. 함수 호출 `CHAR(r,w,c)`는 r번째 행, w번째 단어, c번째 문자를 나타내는 정수를 반환한다. `SETCHAR(r,w,c,d)`를 호출하면 r번째 행의 w번째 단어, c번째 문자가 d가 나타내는 문자로 설정된다. 즉 `CHAR(r,w,c) = d`가 된다. `WORDS(r)`은 r번째 행의 단어 수를 반환한다.

이 루틴들을 호출하는 방식에는 일정한 제약이 있다. 제약을 위반하면 루틴은 사용자가 제공한 에러 처리 서브루틴으로 분기한다. 이 밖에도 특정 행의 단어 수, 현재 저장된 행 수, 특정 단어의 문자 수를 알려주는 루틴이 있다. `DELINE`과 `DELWRD` 함수는 이미 저장된 행의 일부를 삭제하는 데 쓰인다.

유사한 모듈의 정확한 명세는 [3]과 [8]에 나와 있으므로 여기서 반복하지 않는다.

**모듈 2: 입력.** 이 모듈은 입력 매체에서 원본 행을 읽어, 행 저장소 모듈을 호출하여 내부에 저장한다.

**모듈 3: 순환 시프터(Circular Shifter).** 이 모듈이 제공하는 주요 함수는 모듈 1의 함수와 유사하다. 이 모듈은 마치 모든 행의 순환 시프트를 담은 행 저장소가 있는 것처럼 보이게 한다. 함수 호출 `CSCHAR(l,w,c)`는 l번째 순환 시프트의 w번째 단어, c번째 문자를 나타내는 값을 반환한다.

명세에 따르면 두 가지가 정해져 있다. (1) i < j이면 i번째 행의 시프트가 j번째 행의 시프트보다 앞에 온다. (2) 각 행에 대해 첫 번째 시프트는 원래 행이다. 두 번째 시프트는 첫 번째를 한 단어 회전한 것이다. 다른 함수를 사용하기 전에 반드시 `CSSETUP` 함수를 호출해야 한다. 이런 모듈의 더 정확한 명세는 [8]을 참고하라.

**모듈 4: 정렬기(Alphabetizer).** 이 모듈은 주로 두 개의 함수로 구성된다. 하나는 `ALPH`로, 다른 함수를 사용하기 전에 반드시 먼저 호출해야 한다. 다른 하나는 `ITH`로, 인덱스 역할을 한다. `ITH(i)`는 알파벳 순서로 i번째인 순환 시프트의 인덱스를 반환한다. 이 함수들의 형식적 정의는 [8]에 나와 있다.

**모듈 5: 출력.** 이 모듈은 주어진 행 집합이나 순환 시프트를 원하는 형식으로 출력한다.

**모듈 6: 마스터 컨트롤.** 위의 모듈화 1에서와 기능이 비슷하다.

## 두 모듈화의 비교

### 일반 사항

두 방식 모두 동작한다. 첫 번째는 상당히 전통적인 방식이다. 두 번째는 수업 프로젝트 [7]에서 성공적으로 사용한 바 있다. 두 방식 모두 프로그래밍 작업을 비교적 독립적인 여러 소규모 프로그램으로 줄여준다.

먼저 주목할 점이 있다. 두 분해가 같은 자료 표현과 접근 방법을 공유할 수 있다는 것이다. 우리가 논의하는 것은 동일한 대상을 나누는 두 가지 다른 방식이다. 분해 1에 따라 만든 시스템이 어셈블 후에 분해 2에 따라 만든 시스템과 완전히 동일할 수도 있다. 두 대안의 차이는 작업 배분 방식과 모듈 간 인터페이스에 있다. 두 경우에 쓰이는 알고리즘은 동일할 수 있다.

두 시스템은 실행 가능한 표현이 동일하더라도 본질적으로 다르다. 실행 가능한 표현은 실행에만 쓰면 된다. 변경, 문서화, 이해 등에는 다른 표현을 쓰기 때문이다. 두 시스템은 이런 다른 표현에서 동일하지 않다.

### 변경 용이성

여러 설계 결정이 논란의 여지가 있고, 상황에 따라 바뀔 가능성이 높다. 아래는 그 일부 목록이다.

1. **입력 형식.**

2. **모든 행을 메모리에 저장하겠다는 결정.** 대규모 작업에서는 모든 행을 동시에 메모리에 두는 것이 불편하거나 비현실적일 수 있다.

3. **문자를 한 워드에 네 개씩 묶겠다는 결정.** 데이터가 적은 경우에는 묶지 않는 편이 나을 수 있다. 한 워드에 한 문자를 저장하면 시간이 절약된다. 다른 경우에는 묶되 다른 형식을 쓸 수 있다.

4. **순환 시프트를 실제로 저장하지 않고 인덱스를 만들겠다는 결정.** 인덱스가 작거나 메모리가 큰 경우에는 직접 써내는 편이 나을 수 있다. 또는 `CSSETUP` 단계에서 아무것도 준비하지 않고, `CSCHAR` 같은 함수가 호출될 때마다 계산하는 방법도 있다.

5. **리스트를 한 번에 정렬하겠다는 결정.** 대안으로는 (a) 필요할 때마다 항목을 검색하거나, (b) Hoare의 FIND [2]처럼 부분 정렬을 하는 방법이 있다. 여러 상황에서 정렬 계산을 인덱스 생성 시간에 걸쳐 분산시키는 편이 유리하다.

이 변경들을 살펴보면 두 모듈화의 차이가 드러난다.

첫 번째 변경은 두 분해 모두에서 하나의 모듈로 한정된다.

두 번째 변경은 첫 번째 분해에서 **모든 모듈**을 바꿔야 한다. 세 번째 변경도 마찬가지다. 첫 번째 분해에서는 메모리 내 행 저장 형식을 모든 프로그램이 알아야 하기 때문이다. 두 번째 분해에서는 이야기가 완전히 다르다. 행이 실제로 어떻게 저장되는지는 모듈 1 외에는 아무도 모른다. 저장 방식의 어떤 변경이든 그 모듈 안에 한정시킬 수 있다.

이 시스템의 일부 버전에서는 분해에 모듈이 하나 더 있었다. 행 저장소 모듈 안에서 심볼 테이블 모듈([3]에 명세된 것)을 사용한 것이다. 이 사실은 시스템의 나머지에 전혀 드러나지 않았다.

네 번째 변경은 두 번째 분해에서 순환 시프트 모듈로 한정된다. 하지만 첫 번째 분해에서는 정렬기와 출력 루틴도 변경을 알게 된다.

다섯 번째 변경도 첫 번째 분해에서는 어렵다. 출력 모듈이 인덱스 생성 완료를 기다린 뒤에야 시작할 것이기 때문이다. 두 번째 분해의 정렬기 모듈은 사용자가 정렬이 실제로 언제 수행되었는지 알 수 없게 설계되어 있다. 다른 모듈을 바꿀 필요가 없다.

### 독립 개발

첫 번째 모듈화에서 모듈 간 인터페이스는 위에서 설명한 것처럼 꽤 복잡한 형식과 테이블 구조다. 이 형식과 구조는 가볍게 정할 수 있는 설계 결정이 아니다. 테이블의 구조와 구성은 각 모듈의 효율에 필수적이므로 신중하게 설계해야 한다. 이 형식을 개발하는 일이 모듈 개발의 상당 부분을 차지한다. 그 부분은 여러 개발 그룹이 합동으로 해야 한다.

두 번째 모듈화에서 인터페이스는 더 추상적이다. 주로 함수 이름과 매개변수의 수 및 타입으로 구성된다. 비교적 단순한 결정이다. 모듈의 독립 개발을 훨씬 더 일찍 시작할 수 있다.

### 이해 용이성

첫 번째 모듈화에서 출력 모듈을 이해하려면, 정렬기와 순환 시프터와 입력 모듈을 어느 정도 이해해야 한다. 출력이 사용하는 테이블 중 일부는 다른 모듈의 동작 방식을 알아야만 의미가 통한다. 다른 모듈의 알고리즘 때문에 테이블 구조에 제약이 생길 것이다. 시스템을 전체로서만 이해할 수 있다.

두 번째 모듈화에서는 그렇지 않다고 나는 판단한다.

## 분해 기준

많은 독자가 이제 각 분해에 어떤 기준을 썼는지 알 것이다.

첫 번째 분해에서 사용한 기준은 **처리의 각 주요 단계를 모듈로** 만드는 것이었다. 다시 말해, 첫 번째 분해를 얻으려면 흐름도(flowchart)를 그리면 된다. 이것이 분해 또는 모듈화에 가장 흔히 쓰이는 접근법이다. 프로그래머 교육에서 늘 배우는 방식의 연장이다. "대략적인 흐름도를 먼저 그리고, 거기서 세부 구현으로 나아가라." 흐름도는 명령어 5,000~10,000개 규모의 시스템에는 유용한 추상화였다. 하지만 그 규모를 넘어서면 충분하지 않다. 무언가 더 필요하다.

두 번째 분해는 "정보 은닉" [4]을 기준으로 했다. 모듈은 더 이상 처리 단계와 대응하지 않는다. 예를 들어 행 저장소 모듈은 시스템의 거의 모든 동작에서 쓰인다. 정렬은 사용하는 방법에 따라 처리의 한 단계와 대응할 수도 있고 아닐 수도 있다. 마찬가지로, 순환 시프트는 경우에 따라 테이블을 전혀 만들지 않고 요청될 때마다 각 문자를 계산할 수 있다.

두 번째 분해의 모든 모듈에는 공통점이 있다. 각 모듈이 하나의 설계 결정을 다른 모듈로부터 숨긴다. 각 모듈의 인터페이스 또는 정의는 내부 동작에 대해 가능한 한 적게 드러내도록 선택했다.

## 순환 시프트 모듈의 개선

이 기준의 영향을 보여주기 위해 두 번째 분해의 순환 시프트 모듈 설계를 더 자세히 살펴보자. 되돌아보면, 이 정의가 필요 이상으로 많은 정보를 드러내고 있었다. 순환 시프트 목록의 저장 또는 계산 방법은 신중하게 숨겼지만, 그 목록의 **순서**는 명세에 포함시켰다.

다음 세 가지만 명세해도 프로그램을 충분히 작성할 수 있다. (1) 현재 정의에 나타난 행들이 모두 테이블에 존재한다. (2) 같은 행이 두 번 포함되지 않는다. (3) 시프트가 주어졌을 때 원래 행을 식별할 수 있는 함수가 추가로 존재한다.

시프트의 순서를 규정함으로써 필요 이상의 정보를 제공했다. 그 결과, 정의를 바꾸지 않고 만들 수 있는 시스템의 범위를 불필요하게 제한했다. 예를 들어, 순환 시프트를 알파벳 순으로 생성하는 시스템을 생각해 보자. `ALPH`는 빈 함수이고 `ITH`는 인자를 그대로 반환한다. 그런 시스템을 허용하지 못한 것이다. 두 번째 분해로 시스템을 만들 때 이 점을 놓친 것은 분명히 설계 오류로 분류해야 한다.

각 모듈이 어떤 설계 결정을 시스템의 나머지로부터 숨긴다는 일반 기준 외에도, 바람직해 보이는 구체적인 분해 사례를 몇 가지 들 수 있다.

1. **자료 구조, 그 내부 연결, 접근 절차, 수정 절차는 하나의 모듈에 속해야 한다.** 전통적으로 하듯 여러 모듈이 공유해서는 안 된다. 이 개념은 Balzer [9]와 Mealy [10]의 논문 이면에 있는 가정을 정교화한 것이다. BLISS [11]의 설계는 분명히 이 사고방식을 따르고 있다.

2. **특정 루틴을 호출하는 데 필요한 명령어 시퀀스와 그 루틴 자체는 같은 모듈에 속해야 한다.** 이 규칙은 실험에 사용한 Fortran 시스템에서는 해당되지 않았지만, 어셈블리 언어로 만든 시스템에서는 필수적이다. 실제 기계에 완벽한 범용 호출 절차란 없으므로, 이상적인 호출 절차를 계속 탐색하면서 달라지기 마련이다. 호출 코드를 생성하는 책임을 루틴 담당자에게 맡기면, 이런 개선이 쉬워진다. 같은 소프트웨어 구조 안에서 여러 다른 호출 절차를 두는 것도 가능해진다.

3. **운영체제 등에서 큐에 쓰이는 제어 블록의 형식은 "제어 블록 모듈" 안에 숨겨야 한다.** 전통적으로 이런 형식은 모듈 간 인터페이스로 사용한다. 그러나 설계가 발전하면서 제어 블록 형식이 자주 바뀌기 때문에, 이런 결정은 매우 비싼 대가를 치르게 되는 경우가 많다.

4. **문자 코드, 알파벳 순서 등의 데이터는 최대한 유연성을 위해 하나의 모듈 안에 숨겨야 한다.**

5. **특정 항목의 처리 순서는 가능한 한 하나의 모듈 안에 숨겨야 한다.** 장비 추가부터 운영체제에서 특정 자원의 사용 불가까지, 다양한 변경이 처리 순서를 매우 가변적으로 만든다.

## 효율과 구현

주의하지 않으면 두 번째 분해가 첫 번째보다 훨씬 비효율적일 수 있다. 각 함수를 복잡한 호출 절차를 가진 프로시저로 구현하면, 모듈 간 전환이 반복된다. 호출 오버헤드가 매우 커진다. 첫 번째 분해는 모듈 간 제어 이동이 비교적 드물기 때문에 이 문제를 겪지 않는다.

호출 오버헤드를 줄이면서도 위에서 본 장점을 살리려면, 모듈을 색다른 방식으로 구현해야 한다. 많은 경우 루틴을 어셈블러가 코드에 직접 삽입하는 것이 가장 좋다. 다른 경우에는 고도로 특화된 효율적 전환 코드를 삽입할 수 있다.

두 번째 분해를 성공적이고 효율적으로 활용하려면 도구가 필요하다. 프로그램을 마치 함수가 서브루틴인 것처럼 작성하되, 적절한 구현 방식으로 어셈블하는 도구다. 이 기법을 쓰면 최종 코드에서 모듈의 경계가 명확하지 않을 수 있다. 그래서 프로그램 수정 기능도 추가로 유용하다. 다시 말해, 앞서 언급한 프로그램의 여러 표현을 기계 안에 유지해야 한다. 표현 사이의 매핑을 수행하는 프로그램도 함께 갖추어야 한다.

## 컴파일러와 인터프리터에 공통된 분해

이 분해 규칙을 설계 프로젝트에 처음 적용했을 때, [6]에 기술된 표기법의 마르코프 알고리즘 번역기를 만들었다. 컴파일 방식과 해석 방식 번역기의 관계를 조사하려는 의도는 아니었다. 그러나 우리의 분해가 순수 컴파일러와 여러 종류의 인터프리터 모두에 유효하다는 것을 발견했다.

각 유형의 컴파일러의 최종 실행 표현에는 깊고 실질적인 차이가 있을 것이다. 그러나 초기 분해에 내포된 결정들은 모든 경우에 유효했다.

전통적인 기준으로 책임을 나누었다면 이렇게 되지 않았을 것이다. 컴파일러의 구문 인식기, 코드 생성기, 런타임 루틴 같은 기준 말이다. 대신 위 예제처럼 다양한 설계 결정을 숨기는 방식으로 분해했다. 레지스터 표현, 탐색 알고리즘, 규칙 해석 등이 각각 모듈이 되었다. 이 문제들은 컴파일 방식과 해석 방식 번역기 모두에 존재했다. 분해가 모든 경우에 유효했을 뿐 아니라, 많은 루틴을 어떤 번역기에서든 약간만 수정하면 사용할 수 있었다.

이 예제는 두 가지를 추가로 뒷받침한다. 첫째, 처리의 예상 시간 순서를 모듈 분해 기준으로 삼아서는 안 된다. 둘째, 신중한 분해는 한 프로젝트의 작업을 다른 프로젝트로 상당 부분 이월할 수 있게 해 준다.

이 예제에 대한 더 상세한 논의는 [8]에 있다.

## 계층 구조

두 번째 분해에 따라 정의한 시스템에서 Dijkstra [5]가 보여준 방식의 프로그램 계층 구조(hierarchical structure)를 찾을 수 있다. 심볼 테이블이 있다면, 다른 모듈 없이 독자적으로 동작하므로 1단계에 놓인다. 행 저장소는 심볼 테이블을 사용하지 않으면 1단계, 사용하면 2단계에 놓인다. 입력과 순환 시프터는 행 저장소가 있어야 동작한다. 출력과 정렬기는 순환 시프터를 필요로 한다.

순환 시프터와 행 저장소는 어떤 의미에서 호환된다. 따라서 원래 행이든 순환 시프트든 정렬하거나 출력할 수 있는 매개변수화 버전을 쉽게 만들 수 있다. 원래 행에 쓸 때는 순환 시프터가 필요 없고, 순환 시프트에 쓸 때는 필요하다. 다시 말해, 우리의 설계는 계층의 두 단계 중 어느 쪽에서든 실행될 수 있는 단일 프로그램 표현을 가능하게 했다.

시스템 구조를 논의할 때, 좋은 분해의 이점과 계층 구조의 이점을 혼동하기 쉽다. 모듈이나 프로그램 사이에 어떤 관계를 정의할 수 있고, 그 관계가 부분 순서(partial ordering)이면 계층 구조다. 여기서 관심 있는 관계는 "사용한다" 또는 "의존한다"이다. 많은 경우 한 모듈이 다른 모듈의 일부에만 의존한다. 따라서 모듈보다는 프로그램 사이의 관계를 쓰는 편이 낫다. 예를 들어 순환 시프터는 행 저장소의 출력 부분에만 의존하고, `SETWORD`의 올바른 동작에는 의존하지 않는다.

부분 순서 없이도 지금까지 논의한 이점을 얻을 수 있다고 생각할 수 있다. 모든 모듈이 같은 단계에 있어도 말이다. 부분 순서는 두 가지 추가 이점을 준다. 첫째, 시스템의 일부가 하위[^1] 단계의 서비스를 사용하므로 단순해진다.

[^1]: 여기서 "하위"란 "번호가 낮은"을 뜻한다. 둘째, 상위 단계를 잘라내고도 사용 가능하고 유용한 제품을 가질 수 있다. 예를 들어 심볼 테이블은 다른 응용에서 쓸 수 있다. 행 저장소는 질의 응답 시스템의 기반이 될 수 있다. 계층 구조가 있으면 트리의 윗부분을 잘라낼 수 있다. 기존 줄기 위에 새 트리를 시작할 수 있다.

만약 "하위" 모듈이 "상위" 모듈을 사용하는 시스템을 설계했다면, 계층은 없을 것이다. 시스템의 일부를 분리하기가 훨씬 어려워지고, "단계"라는 말이 별 의미를 갖지 못할 것이다.

분해 1처럼 중요한 설계 결정이 인터페이스에 노출되더라도, 계층 구조를 유지하는 시스템을 가질 수도 있다. 따라서 계층 구조와 "깨끗한" 분해는 둘 다 바람직하지만, 서로 독립적인 속성이라고 결론지어야 한다.

## 결론

이 예제들을 통해 다음을 보여주려 했다. 흐름도를 기초로 시스템을 모듈로 분해하는 것은 거의 항상 잘못이다. 대신 어려운 설계 결정, 또는 변경될 가능성이 높은 설계 결정의 목록에서 시작할 것을 제안한다. 그런 다음 각 모듈이 그런 결정 하나를 다른 모듈로부터 숨기도록 설계한다.

대부분의 경우 설계 결정은 실행 시점을 초월하므로, 모듈은 처리 단계와 대응하지 않는다. 효율적으로 구현하려면 모듈이 곧 서브루틴이라는 가정을 버려야 한다. 대신 서브루틴과 프로그램이 여러 모듈의 코드를 모아 조립한 것이 되도록 해야 한다.

## References

1. Gauthier, Richard, and Pont, Stephen. *Designing Systems Programs*, Prentice-Hall, Englewood Cliffs, N.J., 1970.
2. Hoare, C. A. R. Proof of a program, FIND. *Comm. ACM* 14, 1 (Jan. 1971), 39-45.
3. Parnas, D. L. A technique for software module specification with examples. *Comm. ACM* 15, 5 (May, 1972), 330-336.
4. Parnas, D. L. Information distribution aspects of design methodology. Tech. Rept., Dept. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971. Also presented at the IFIP Congress 1971, Ljubljana, Yugoslavia.
5. Dijkstra, E. W. The structure of "THE"-multiprogramming system. *Comm. ACM* 11, 5 (May 1968), 341-346.
6. Galler, B., and Perlis, A. J. *A View of Programming Languages*, Addison-Wesley, Reading, Mass., 1970.
7. Parnas, D. L. A course on software engineering. *Proc. SIGCSE Technical Symposium*, Mar. 1972.
8. Parnas, D. L. On the criteria to be used in decomposing systems into modules. Tech. Rept., Dept. Computer Science, Carnegie-Mellon U., Pittsburgh, Pa., 1971.
9. Balzer, R. M. Dataless programming. *Proc. AFIPS 1967 FJCC*, Vol. 31, AFIPS Press, Montvale, N.J., pp. 535-544.
10. Mealy, G. H. Another look at data. *Proc. AFIPS 1967 FJCC*, Vol. 31, AFIPS Press, Montvale, N.J., pp. 525-534.
11. Wulf, W. A., Russell, D. B., and Habermann, A. N. BLISS, A language for systems programming. *Comm. ACM* 14, 12 (Dec. 1971), 780-790.

---

## wiki.c2.com 토론

[DavidParnas](http://wiki.c2.com/?DavidParnas)가 1972년에 발표한 논문 "On the Criteria To Be Used in Decomposing Systems into Modules"의 짧은 [WikiName](http://wiki.c2.com/?WikiName)이다.

참고:
- http://www.acm.org/classics/may96/
- http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf

---

> [RelationalWeenie](http://wiki.c2.com/?RelationalWeenie)로서 나는 이 논문이 배열이나 연결 리스트를 직접 만들지 말고 [DataBase](http://wiki.c2.com/?DataBase)를 쓰라는 주장으로 읽힌다. Parnas가 선호하는 해법은 일종의 미니 데이터베이스처럼 보인다. 하지만 이 논문은 각자 보고 싶은 것을 보게 만드는 글이다. OO 팬은 ADT 캡슐화를 보고, DB 팬은 데이터베이스를 본다. 이 논문으로 [HolyWar](http://wiki.c2.com/?HolyWar)가 끝나지는 않을 것이다. -- top

> 이 논문은 훌륭한 논문이다. 그렇다고 [HolyWar](http://wiki.c2.com/?HolyWar)를 끝낼 수 있다는 뜻은 아니다. 논문은 성전을 시작할 수 있을 뿐, 끝낼 수는 없다. -- [RalphJohnson](http://wiki.c2.com/?RalphJohnson)

> 이 논문은 1972년에 쓰였다. OO와 비교하지 않은 것은 당연하다. 당시 OO는 아직 연구 단계였다. 이 논문은 원칙과 전문적 판단에 관한 글이다. 마법 같은 방법론이 나타나서 전문적 판단이 필요 없어지기 전까지는, 우리 앞에 온 위대한 선배들의 생각을 들여다보는 것이 유용하다. 전문적 판단이 모든 복잡한 분야에서 필수라는 사실을 받아들여야 한다. -- [MarcGrundfest](http://wiki.c2.com/?MarcGrundfest)

> 이 논문은 [GoodMetricsProduceNumbers](http://wiki.c2.com/?GoodMetricsProduceNumbers) 기준에서 미흡하다. "X를 하면 Y가 쉬워진다"는 주장은 많지만, X가 실제로 얼마나 자주 일어나는지에 대한 확률 분석이 없다. 확률이 낮으면 현실에는 별 의미가 없다. **확률은 설계 선택에서 가장 중요한 요소다.** 많은 사람이 이를 무시한다. -- top

> 사실 이 논문은 이미 수백 개의 후속 연구, 프로그래밍 언어, 소프트웨어 제품이 해부하고 검증했다. Parnas는 "인터페이스에 맞춰 프로그래밍하라"는 개념을 가장 보편적인 형태로 처음 문서화한 사람 중 하나다. 그 용어를 쓰지는 않았지만 말이다. 이 논문이 중요한 이유는 역사적 출발점이기 때문이다. 이 개념이 보편적으로 적용 가능한지, 어떻게 정량화할 수 있는지는 후속 연구의 몫이다.

---

### On Implementation Hiding

> 구현을 "숨기는 것"보다 유연하게 만드는 것이 더 중요하다. 구현 은닉의 가치는 과대평가되는 경우가 많다. 다른 조건이 같다면 추구할 만하지만, 구현 유연성을 희생하면서까지 할 일은 아니다. -- top

> 비즈니스 리포트 같은 소규모 애플리케이션이라면 그 말이 맞다. 보통 한 사람이 유지보수하고, 변경이 잦으며, 어제까지 완료해야 한다. 이런 상황에서 구현 은닉을 위한 구조적 장치는 대부분 장애물일 뿐이다. 다만 재사용 라이브러리에서는 다르다. 내부 구현을 버전마다 개선하면서도 기존 코드를 깨뜨리지 않으려면 은닉이 필요하다.

> 대규모 엔터프라이즈 시스템이라면 이야기가 다르다. 수십 명의 개발자가 복잡하고 비교적 안정적인 기능을 다룬다. 구현 세부사항이 노출되면 다른 개발자가 내부 메커니즘에 의존한다. 그러면 변경이 어렵고 위험해진다.

---

## 키워드

information hiding, modularization, decomposition, KWIC index, changeability, design decision, hierarchical structure, module, encapsulation

## 관련 문서

- [EncapsulationIsNotInformationHiding](http://wiki.c2.com/?EncapsulationIsNotInformationHiding)
- [PerceptionOfChange](http://wiki.c2.com/?PerceptionOfChange)
- [OoConflictsWithCollectionOrientation](http://wiki.c2.com/?OoConflictsWithCollectionOrientation)
- [CategoryInfoPackaging](http://wiki.c2.com/?CategoryInfoPackaging)
